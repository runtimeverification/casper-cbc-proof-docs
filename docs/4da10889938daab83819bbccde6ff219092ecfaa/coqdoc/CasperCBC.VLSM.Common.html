<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<link href="coqdocjs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="config.js"></script>
<script type="text/javascript" src="coqdocjs.js"></script>
</head>

<body onload="document.getElementById('content').focus()">
  <div id="header">
    <span class="left">
      <span class="modulename"> <script> document.write(document.title) </script> </span>
    </span>

    <span class="button" id="toggle-proofs"></span>

    <span class="right">
      <a href="./../../..">Project Website</a>
      <a href="./indexpage.html">Index</a>
      <a href="./toc.html">Table of Contents</a>
    </span>
</div>
    <div id="content" tabindex="-1" onblur="document.getElementById('content').focus()">
    <div id="main">
<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Nat.html#"><span class="id" title="library">Nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.micromega.Lia.html#"><span class="id" title="library">Lia</span></a>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#"><span class="id" title="library">List</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.Streams.html#"><span class="id" title="library">Streams</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Logic.ProofIrrelevance.html#"><span class="id" title="library">ProofIrrelevance</span></a>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">ListNotations</span>.<br/>

<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">CasperCBC</span><br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="CasperCBC.Lib.Preamble.html#"><span class="id" title="library">Lib.Preamble</span></a> <a class="idref" href="CasperCBC.Lib.ListExtras.html#"><span class="id" title="library">Lib.ListExtras</span></a> <a class="idref" href="CasperCBC.Lib.StreamExtras.html#"><span class="id" title="library">Lib.StreamExtras</span></a>.<br/>

<br/>
</div>

<div class="doc">
This module provides basic VLSM infrastructure

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<a name="lab1"></a><h1 class="section">VLSM definition</h1>


<div class="paragraph"> </div>

<a name="lab2"></a><h2 class="section">The type of a VLSM</h2>


<div class="paragraph"> </div>

The type of a VLSM is a triple consisting of the undelying types of
messages, states, and labels.

<div class="paragraph"> </div>

In Coq it is defined as a Class taking <tt>message</tt> as parameter and having
<span class="inlinecode"><a class="idref" href="CasperCBC.CBC.Protocol.html#state"><span class="id" title="projection">state</span></a></span> and <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="projection">label</span></a></span> as fields.  <tt>message</tt> is a parameter to allow it to be
easily shared by multiple VLSMs during composition.

<div class="paragraph"> </div>


</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Class</span> <a name="VLSM_type"><span class="id" title="record">VLSM_type</span></a> (<span class="id" title="var">message</span> : <span class="id" title="keyword">Type</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <a name="state"><span class="id" title="projection">state</span></a> : <span class="id" title="keyword">Type</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;; <a name="label"><span class="id" title="projection">label</span></a> : <span class="id" title="keyword">Type</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;}.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<a name="lab3"></a><h2 class="section">The signature of a VLSM</h2>


<div class="paragraph"> </div>

Although the VLSM definition does not single out the notion of a VLSM
signature, we find it convenient to extract it as the <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_sign"><span class="id" title="record">VLSM_sign</span></a></span> class.

<div class="paragraph"> </div>

The <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_sign"><span class="id" title="record">VLSM_sign</span></a></span> class is parameterized by a <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_type"><span class="id" title="record">VLSM_type</span></a></span> and defines properties
for initial states (<span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.FullNodeComposite.html#initial_state_prop"><span class="id" title="definition">initial_state_prop</span></a></span>) and initial messages
(<span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.FullNodeComposite.html#initial_message_prop"><span class="id" title="definition">initial_message_prop</span></a></span>), from which we can immediately define the dependent
types <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#initial_state"><span class="id" title="method">initial_state</span></a></span> (as <span class="inlinecode"><a class="idref" href="CasperCBC.CBC.Protocol.html#state"><span class="id" title="projection">state</span></a></span>s having the <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.FullNodeComposite.html#initial_state_prop"><span class="id" title="definition">initial_state_prop</span></a></span>erty) and
<span class="inlinecode"><span class="id" title="var">intial_message</span></span> (as <tt>message</tt>s having the <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.FullNodeComposite.html#initial_message_prop"><span class="id" title="definition">initial_message_prop</span></a></span>erty).

<div class="paragraph"> </div>

Additionally, <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_sign"><span class="id" title="record">VLSM_sign</span></a></span> requires the identification of an <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#initial_state"><span class="id" title="method">initial_state</span></a></span> <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#s0"><span class="id" title="projection">s0</span></a></span>,
a <tt>message</tt> <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#m0"><span class="id" title="projection">m0</span></a></span>, and a <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="projection">label</span></a></span> <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#l0"><span class="id" title="projection">l0</span></a></span> to ensure the non-emptiness of the
corresponding sets.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Class</span> <a name="VLSM_sign"><span class="id" title="record">VLSM_sign</span></a> {<span class="id" title="var">message</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">vtype</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_type"><span class="id" title="class">VLSM_type</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#message"><span class="id" title="variable">message</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <a name="initial_state_prop"><span class="id" title="projection">initial_state_prop</span></a> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;; <span class="id" title="var">initial_state</span> := <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">{</span></a> <span class="id" title="var">s</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">:</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">|</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#initial_state_prop"><span class="id" title="method">initial_state_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">}</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;; <a name="initial_message_prop"><span class="id" title="projection">initial_message_prop</span></a> : <a class="idref" href="CasperCBC.VLSM.Common.html#message"><span class="id" title="variable">message</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;; <span class="id" title="var">initial_message</span> := <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">{</span></a> <span class="id" title="var">m</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">:</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#message"><span class="id" title="variable">message</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">|</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#initial_message_prop"><span class="id" title="method">initial_message_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">}</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;; <a name="s0"><span class="id" title="projection">s0</span></a> : <a class="idref" href="CasperCBC.VLSM.Common.html#initial_state"><span class="id" title="method">initial_state</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;; <a name="m0"><span class="id" title="projection">m0</span></a> : <a class="idref" href="CasperCBC.VLSM.Common.html#message"><span class="id" title="variable">message</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;; <a name="l0"><span class="id" title="projection">l0</span></a> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;}.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<a name="lab4"></a><h2 class="section">VLSM class definition</h2>


<div class="paragraph"> </div>

Given a V<span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_sign"><span class="id" title="record">VLSM_sign</span></a></span>nature, a <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#VLSM"><span class="id" title="section">VLSM</span></a></span> is defined by providing a <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#transition"><span class="id" title="projection">transition</span></a></span>
function and a <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#valid"><span class="id" title="projection">valid</span></a></span>ity condition.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Class</span> <a name="VLSM"><span class="id" title="record">VLSM</span></a> {<span class="id" title="var">message</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">vtype</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_type"><span class="id" title="class">VLSM_type</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#message"><span class="id" title="variable">message</span></a>} (<span class="id" title="var">lsm</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_sign"><span class="id" title="class">VLSM_sign</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#vtype"><span class="id" title="variable">vtype</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <a name="transition"><span class="id" title="projection">transition</span></a> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">*</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#message"><span class="id" title="variable">message</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">*</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#message"><span class="id" title="variable">message</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;; <a name="valid"><span class="id" title="projection">valid</span></a> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">*</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#message"><span class="id" title="variable">message</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;}.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Given a <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#VLSM"><span class="id" title="section">VLSM</span></a></span>, it is convenient to be able to retrieve its V<span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_sign"><span class="id" title="record">VLSM_sign</span></a></span>nature
or <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_type"><span class="id" title="record">VLSM_type</span></a></span>. Functions <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#sign"><span class="id" title="definition">sign</span></a></span> and <span class="inlinecode"><span class="id" title="keyword">type</span></span> below achieve this precise purpose.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="sign"><span class="id" title="definition">sign</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">message</span> : <span class="id" title="keyword">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">vtype</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_type"><span class="id" title="class">VLSM_type</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#message"><span class="id" title="variable">message</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">Sig</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_sign"><span class="id" title="class">VLSM_sign</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#vtype"><span class="id" title="variable">vtype</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">vlsm</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM"><span class="id" title="class">VLSM</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Sig"><span class="id" title="variable">Sig</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;:= <a class="idref" href="CasperCBC.VLSM.Common.html#Sig"><span class="id" title="variable">Sig</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="type"><span class="id" title="definition">type</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">message</span> : <span class="id" title="keyword">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">vtype</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_type"><span class="id" title="class">VLSM_type</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#message"><span class="id" title="variable">message</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">Sig</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_sign"><span class="id" title="class">VLSM_sign</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#vtype"><span class="id" title="variable">vtype</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">vlsm</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM"><span class="id" title="class">VLSM</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Sig"><span class="id" title="variable">Sig</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;:= <a class="idref" href="CasperCBC.VLSM.Common.html#vtype"><span class="id" title="variable">vtype</span></a>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Section</span> <a name="VLSM"><span class="id" title="section">VLSM</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

In this section we assume a fixed <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#VLSM"><span class="id" title="section">VLSM</span></a></span>.

</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Context</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">message</span> : <span class="id" title="keyword">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">vtype</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_type"><span class="id" title="class">VLSM_type</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#message"><span class="id" title="variable">message</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">Sig</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_sign"><span class="id" title="class">VLSM_sign</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#vtype"><span class="id" title="variable">vtype</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">vlsm</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM"><span class="id" title="class">VLSM</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Sig"><span class="id" title="variable">Sig</span></a>).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<a name="lab5"></a><h2 class="section">Protocol states and messages</h2>


<div class="paragraph"> </div>

We further characterize certain objects as being <i>protocol</i>, which means they can
be witnessed or experienced during executions of the protocol. For example,
a message is a <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_message"><span class="id" title="definition">protocol_message</span></a></span> if there exists an execution of the protocol
in which it is produced.

<div class="paragraph"> </div>

We choose here to define protocol states and messages together as the
<span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_prop"><span class="id" title="inductive">protocol_prop</span></a></span> property, inductively defined over the
<span class="inlinecode"><a class="idref" href="CasperCBC.CBC.Protocol.html#state"><span class="id" title="projection">state</span></a></span> <span class="inlinecode">*</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a></span> <span class="inlinecode"><a class="idref" href="CasperCBC.CBC.LightNode.html#message"><span class="id" title="definition">message</span></a></span> product type,
as this definition avoids the need of using a mutually recursive definition.

<div class="paragraph"> </div>

The inductive definition has three cases:
<ul class="doclist">
<li> if <tt>s</tt> is a <span class="inlinecode"><a class="idref" href="CasperCBC.CBC.Protocol.html#state"><span class="id" title="projection">state</span></a></span> with the <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.FullNodeComposite.html#initial_state_prop"><span class="id" title="definition">initial_state_prop</span></a></span>erty, then <tt>(s, None)</tt> has the <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_prop"><span class="id" title="inductive">protocol_prop</span></a></span>erty;

</li>
<li> if <tt>m</tt> is a <tt>message</tt> with the <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.FullNodeComposite.html#initial_message_prop"><span class="id" title="definition">initial_message_prop</span></a></span>erty, then <tt>(</tt><span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#s0"><span class="id" title="projection">s0</span></a>,</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a></span><tt>m)</tt> has the <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_prop"><span class="id" title="inductive">protocol_prop</span></a></span>erty;

</li>
<li> for all <span class="inlinecode"><a class="idref" href="CasperCBC.CBC.Protocol.html#state"><span class="id" title="projection">state</span></a></span>s <tt>s</tt>, <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a></span>al <tt>message</tt> <tt>om</tt>,
  and <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="projection">label</span></a></span> <tt>l</tt>:

<div class="paragraph"> </div>

  if there is an (optional) <tt>message</tt> <tt>_om</tt> such that <tt>(s, _om)</tt> has the <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_prop"><span class="id" title="inductive">protocol_prop</span></a></span>erty;

<div class="paragraph"> </div>

  and if there is a <span class="inlinecode"><a class="idref" href="CasperCBC.CBC.Protocol.html#state"><span class="id" title="projection">state</span></a></span> <tt>_s</tt> such that <tt>(_s, om)</tt> has the <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_prop"><span class="id" title="inductive">protocol_prop</span></a></span>erty;

<div class="paragraph"> </div>

  and if <tt>l</tt> <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#valid"><span class="id" title="projection">valid</span></a></span> <tt>(s, om)</tt>,

<div class="paragraph"> </div>

  then <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#transition"><span class="id" title="projection">transition</span></a></span> <tt>l (s, om)</tt> has the <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_prop"><span class="id" title="inductive">protocol_prop</span></a></span>erty.

</li>
</ul>

</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <a name="protocol_prop"><span class="id" title="inductive">protocol_prop</span></a> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">*</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="protocol_initial_state"><span class="id" title="constructor">protocol_initial_state</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">is</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#initial_state"><span class="id" title="method">initial_state</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> := <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#proj1_sig"><span class="id" title="definition">proj1_sig</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#is"><span class="id" title="variable">is</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_prop"><span class="id" title="inductive">protocol_prop</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="protocol_initial_message"><span class="id" title="constructor">protocol_initial_message</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">im</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#initial_message"><span class="id" title="method">initial_message</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> := <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#proj1_sig"><span class="id" title="definition">proj1_sig</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s0"><span class="id" title="method">s0</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">om</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a> := <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#proj1_sig"><span class="id" title="definition">proj1_sig</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#im"><span class="id" title="variable">im</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_prop"><span class="id" title="inductive">protocol_prop</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="protocol_generated"><span class="id" title="constructor">protocol_generated</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">_om</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Hps</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_prop"><span class="id" title="inductive">protocol_prop</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#_om"><span class="id" title="variable">_om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">_s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">om</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Hpm</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_prop"><span class="id" title="inductive">protocol_prop</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#_s"><span class="id" title="variable">_s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Hv</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#valid"><span class="id" title="method">valid</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_prop"><span class="id" title="inductive">protocol_prop</span></a> (<a class="idref" href="CasperCBC.VLSM.Common.html#transition"><span class="id" title="method">transition</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_state_prop"><span class="id" title="definition">protocol_state_prop</span></a></span>erty and the <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_message_prop"><span class="id" title="definition">protocol_message_prop</span></a></span>erty are now
definable as simple projections of the above definition.

<div class="paragraph"> </div>

Moreover, we use these derived properties to define the corresponding
dependent types <span class="inlinecode"><a class="idref" href="CasperCBC.CBC.LightNode.html#protocol_state"><span class="id" title="inductive">protocol_state</span></a></span> and <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_message"><span class="id" title="definition">protocol_message</span></a></span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="protocol_state_prop"><span class="id" title="definition">protocol_state_prop</span></a> (<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <span class="id" title="var">om</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_prop"><span class="id" title="inductive">protocol_prop</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="protocol_message_prop"><span class="id" title="definition">protocol_message_prop</span></a> (<span class="id" title="var">m</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_prop"><span class="id" title="inductive">protocol_prop</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#m"><span class="id" title="variable">m</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">))</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="protocol_state"><span class="id" title="definition">protocol_state</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">{</span></a> <span class="id" title="var">s</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">:</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">|</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_state_prop"><span class="id" title="definition">protocol_state_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">}</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="protocol_message"><span class="id" title="definition">protocol_message</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">{</span></a> <span class="id" title="var">m</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">:</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">|</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_message_prop"><span class="id" title="definition">protocol_message_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">}</span></a>.<br/>

<br/>
</div>

<div class="doc">
As often times we work with optional protocol messages, it is convenient
to define a protocol message property for optional messages:

</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="option_protocol_message_prop"><span class="id" title="definition">option_protocol_message_prop</span></a> (<span class="id" title="var">om</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_prop"><span class="id" title="inductive">protocol_prop</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="option_protocol_message_None"><span class="id" title="lemma">option_protocol_message_None</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#option_protocol_message_prop"><span class="id" title="definition">option_protocol_message_prop</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#proj1_sig"><span class="id" title="definition">proj1_sig</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s0"><span class="id" title="method">s0</span></a>). <span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_initial_state"><span class="id" title="constructor">protocol_initial_state</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="option_protocol_message_Some"><span class="id" title="lemma">option_protocol_message_Some</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">m</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Hpm</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_message_prop"><span class="id" title="definition">protocol_message_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#m"><span class="id" title="variable">m</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#option_protocol_message_prop"><span class="id" title="definition">option_protocol_message_prop</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#m"><span class="id" title="variable">m</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Hpm</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">s</span> <span class="id" title="var">Hpm</span>]. <span class="id" title="tactic">exists</span> <span class="id" title="var">s</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<a name="lab6"></a><h2 class="section">Protocol validity and protocol transitions</h2>


<div class="paragraph"> </div>

To achieve this, it is useful to further define <i>protocol</i> validity and
<i>protocol</i> transitions:

</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="protocol_valid"><span class="id" title="definition">protocol_valid</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">som</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">*</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> (<span class="id" title="var">s</span>, <span class="id" title="var">om</span>) := <a class="idref" href="CasperCBC.VLSM.Common.html#som"><span class="id" title="variable">som</span></a> <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_state_prop"><span class="id" title="definition">protocol_state_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">/\</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#option_protocol_message_prop"><span class="id" title="definition">option_protocol_message_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">/\</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#valid"><span class="id" title="method">valid</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="protocol_transition"><span class="id" title="definition">protocol_transition</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">som</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">*</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">som'</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">*</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_valid"><span class="id" title="definition">protocol_valid</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#som"><span class="id" title="variable">som</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">/\</span></a>  <a class="idref" href="CasperCBC.VLSM.Common.html#transition"><span class="id" title="method">transition</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#som"><span class="id" title="variable">som</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#som'"><span class="id" title="variable">som'</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="can_emit"><span class="id" title="definition">can_emit</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">m</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:= <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">(</span></a><span class="id" title="var">som</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">*</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">),</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition"><span class="id" title="definition">protocol_transition</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#som"><span class="id" title="variable">som</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#m"><span class="id" title="variable">m</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/>

<br/>
</div>

<div class="doc">
  Next three lemmas show the two definitions above are strongly related.

</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="protocol_transition_valid"><span class="id" title="lemma">protocol_transition_valid</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">som</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">*</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">som'</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">*</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Ht</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition"><span class="id" title="definition">protocol_transition</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#som"><span class="id" title="variable">som</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#som'"><span class="id" title="variable">som'</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_valid"><span class="id" title="definition">protocol_valid</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#som"><span class="id" title="variable">som</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Ht</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Hpv</span> <span class="id" title="var">Ht</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="protocol_valid_transition"><span class="id" title="lemma">protocol_valid_transition</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">som</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">*</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Hv</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_valid"><span class="id" title="definition">protocol_valid</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#som"><span class="id" title="variable">som</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">(</span></a><span class="id" title="var">som'</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">*</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">),</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition"><span class="id" title="definition">protocol_transition</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#som"><span class="id" title="variable">som</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#som'"><span class="id" title="variable">som'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<a class="idref" href="CasperCBC.VLSM.Common.html#transition"><span class="id" title="method">transition</span></a> <span class="id" title="var">l</span> <span class="id" title="var">som</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">split</span>; <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="protocol_valid_transition_iff"><span class="id" title="lemma">protocol_valid_transition_iff</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">som</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">*</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_valid"><span class="id" title="definition">protocol_valid</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#som"><span class="id" title="variable">som</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#4bfb4f2d0721ba668e3a802ab1b745a1"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">(</span></a><span class="id" title="var">som'</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">*</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">),</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition"><span class="id" title="definition">protocol_transition</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#som"><span class="id" title="variable">som</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#som'"><span class="id" title="variable">som'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_valid_transition"><span class="id" title="lemma">protocol_valid_transition</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [<span class="id" title="var">som'</span> <span class="id" title="var">Hpt</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition_valid"><span class="id" title="lemma">protocol_transition_valid</span></a> <span class="id" title="keyword">with</span> <span class="id" title="var">som'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The next couple of lemmas relate the two definitions above with 
pre-existing concepts.

<div class="paragraph"> </div>


</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="protocol_generated_valid"><span class="id" title="lemma">protocol_generated_valid</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">_om</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">_s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">om</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Hps</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_prop"><span class="id" title="inductive">protocol_prop</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#_om"><span class="id" title="variable">_om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Hpm</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_prop"><span class="id" title="inductive">protocol_prop</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#_s"><span class="id" title="variable">_s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Hv</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#valid"><span class="id" title="method">valid</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_valid"><span class="id" title="definition">protocol_valid</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">split</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">exists</span> <span class="id" title="var">_om</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">exists</span> <span class="id" title="var">_s</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="protocol_transition_origin"><span class="id" title="lemma">protocol_transition_origin</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">s</span> <span class="id" title="var">s'</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">om</span> <span class="id" title="var">om'</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Ht</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition"><span class="id" title="definition">protocol_transition</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s'"><span class="id" title="variable">s'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#om'"><span class="id" title="variable">om'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_state_prop"><span class="id" title="definition">protocol_state_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Ht</span> <span class="id" title="keyword">as</span> [[[<span class="id" title="var">_om</span> <span class="id" title="var">Hp</span>] <span class="id" title="var">_</span>] <span class="id" title="var">_</span>]. <span class="id" title="tactic">exists</span> <span class="id" title="var">_om</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="protocol_transition_destination"><span class="id" title="lemma">protocol_transition_destination</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">s</span> <span class="id" title="var">s'</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">om</span> <span class="id" title="var">om'</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Ht</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition"><span class="id" title="definition">protocol_transition</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s'"><span class="id" title="variable">s'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om'"><span class="id" title="variable">om'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_state_prop"><span class="id" title="definition">protocol_state_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s'"><span class="id" title="variable">s'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> <span class="id" title="var">om'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Ht</span> <span class="id" title="keyword">as</span> [[[<span class="id" title="var">_om</span> <span class="id" title="var">Hs</span>] [[<span class="id" title="var">_s</span> <span class="id" title="var">Hom</span>] <span class="id" title="var">Hv</span>]] <span class="id" title="var">Ht</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">Ht</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_generated"><span class="id" title="constructor">protocol_generated</span></a> <span class="id" title="keyword">with</span> <span class="id" title="var">_om</span> <span class="id" title="var">_s</span>; <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="protocol_transition_in"><span class="id" title="lemma">protocol_transition_in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">s</span> <span class="id" title="var">s'</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">m</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">om'</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Ht</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition"><span class="id" title="definition">protocol_transition</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#m"><span class="id" title="variable">m</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">))</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s'"><span class="id" title="variable">s'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om'"><span class="id" title="variable">om'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_message_prop"><span class="id" title="definition">protocol_message_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#m"><span class="id" title="variable">m</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Ht</span> <span class="id" title="keyword">as</span> [[<span class="id" title="var">_</span> [[<span class="id" title="var">_s</span> <span class="id" title="var">Hom</span>] <span class="id" title="var">_</span>]] <span class="id" title="var">_</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> <span class="id" title="var">_s</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="protocol_prop_transition_in"><span class="id" title="lemma">protocol_prop_transition_in</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">s</span> <span class="id" title="var">s'</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">om</span> <span class="id" title="var">om'</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Ht</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition"><span class="id" title="definition">protocol_transition</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s'"><span class="id" title="variable">s'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om'"><span class="id" title="variable">om'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <span class="id" title="var">_s</span><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_prop"><span class="id" title="inductive">protocol_prop</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#_s"><span class="id" title="variable">_s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">om</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">m</span>|].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition_in"><span class="id" title="lemma">protocol_transition_in</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">Ht</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">Ht</span>. <span class="id" title="tactic">exists</span> <span class="id" title="var">x</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">exists</span> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#proj1_sig"><span class="id" title="definition">proj1_sig</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s0"><span class="id" title="method">s0</span></a>). <span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="protocol_prop_transition_out"><span class="id" title="lemma">protocol_prop_transition_out</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">s</span> <span class="id" title="var">s'</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">om</span> <span class="id" title="var">om'</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Ht</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition"><span class="id" title="definition">protocol_transition</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s'"><span class="id" title="variable">s'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om'"><span class="id" title="variable">om'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_prop"><span class="id" title="inductive">protocol_prop</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s'"><span class="id" title="variable">s'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om'"><span class="id" title="variable">om'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Ht</span> <span class="id" title="keyword">as</span> [[[<span class="id" title="var">_om</span> <span class="id" title="var">Hps</span>] [[<span class="id" title="var">_s</span> <span class="id" title="var">Hpm</span>] <span class="id" title="var">Hv</span>]] <span class="id" title="var">Ht</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">Ht</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_generated"><span class="id" title="constructor">protocol_generated</span></a> <span class="id" title="keyword">with</span> <span class="id" title="var">_om</span> <span class="id" title="var">_s</span>; <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="protocol_transition_is_valid"><span class="id" title="lemma">protocol_transition_is_valid</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">s</span> <span class="id" title="var">s'</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">om</span> <span class="id" title="var">om'</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Ht</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition"><span class="id" title="definition">protocol_transition</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s'"><span class="id" title="variable">s'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om'"><span class="id" title="variable">om'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#valid"><span class="id" title="method">valid</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Ht</span> <span class="id" title="keyword">as</span> [[<span class="id" title="var">_</span> [<span class="id" title="var">_</span> <span class="id" title="var">Hv</span>]] <span class="id" title="var">_</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="protocol_transition_transition"><span class="id" title="lemma">protocol_transition_transition</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">s</span> <span class="id" title="var">s'</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">om</span> <span class="id" title="var">om'</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Ht</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition"><span class="id" title="definition">protocol_transition</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s'"><span class="id" title="variable">s'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om'"><span class="id" title="variable">om'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:  <a class="idref" href="CasperCBC.VLSM.Common.html#transition"><span class="id" title="method">transition</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s'"><span class="id" title="variable">s'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om'"><span class="id" title="variable">om'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Ht</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">_</span> <span class="id" title="var">Ht</span>]. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="protocol_prop_valid_out"><span class="id" title="lemma">protocol_prop_valid_out</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">om</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Hv</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_valid"><span class="id" title="definition">protocol_valid</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_prop"><span class="id" title="inductive">protocol_prop</span></a> (<a class="idref" href="CasperCBC.VLSM.Common.html#transition"><span class="id" title="method">transition</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_valid_transition"><span class="id" title="lemma">protocol_valid_transition</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">Hv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Hv</span> <span class="id" title="keyword">as</span> [[<span class="id" title="var">s'</span> <span class="id" title="var">om'</span>] <span class="id" title="var">Ht</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition_transition"><span class="id" title="lemma">protocol_transition_transition</span></a>  <span class="id" title="var">Ht</span>); <span class="id" title="tactic">intro</span> <span class="id" title="var">Hteq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hteq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_prop_transition_out"><span class="id" title="lemma">protocol_prop_transition_out</span></a> <span class="id" title="var">Ht</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<a name="lab7"></a><h2 class="section">Protocol state and protocol message characterization</h2>


<div class="paragraph"> </div>

The definition and results below show that the mutually-recursive definitions
for <span class="inlinecode"><a class="idref" href="CasperCBC.CBC.LightNode.html#protocol_state"><span class="id" title="inductive">protocol_state</span></a></span>s and <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_message"><span class="id" title="definition">protocol_message</span></a></span>s can be derived from the
prior definitions.

<div class="paragraph"> </div>

The results below offers equivalent characterizations for <span class="inlinecode"><a class="idref" href="CasperCBC.CBC.LightNode.html#protocol_state"><span class="id" title="inductive">protocol_state</span></a></span>s
and <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_message"><span class="id" title="definition">protocol_message</span></a></span>s, similar to their recursive definition.

</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="protocol_state_prop_iff"><span class="id" title="lemma">protocol_state_prop_iff</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">s'</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_state_prop"><span class="id" title="definition">protocol_state_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s'"><span class="id" title="variable">s'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#4bfb4f2d0721ba668e3a802ab1b745a1"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#f031fe1957c4a4a8e217aa46af2b4e25"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <span class="id" title="keyword">is</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#initial_state"><span class="id" title="method">initial_state</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s'"><span class="id" title="variable">s'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#proj1_sig"><span class="id" title="definition">proj1_sig</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#is"><span class="id" title="variable">is</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#f031fe1957c4a4a8e217aa46af2b4e25"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#f031fe1957c4a4a8e217aa46af2b4e25"><span class="id" title="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">(</span></a><span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>) (<span class="id" title="var">som</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">*</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>) (<span class="id" title="var">om'</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">),</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition"><span class="id" title="definition">protocol_transition</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#som"><span class="id" title="variable">som</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s'"><span class="id" title="variable">s'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om'"><span class="id" title="variable">om'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intro</span> <span class="id" title="var">Hps'</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">Hps'</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">om'</span> <span class="id" title="var">Hs</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">Hs</span>; <span class="id" title="tactic">subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; <span class="id" title="tactic">try</span> (<span class="id" title="tactic">left</span>; <span class="id" title="tactic">exists</span> <span class="id" title="keyword">is</span>; <span class="id" title="tactic">reflexivity</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; <span class="id" title="tactic">try</span> (<span class="id" title="tactic">left</span>; <span class="id" title="tactic">exists</span> <a class="idref" href="CasperCBC.VLSM.Common.html#s0"><span class="id" title="method">s0</span></a>; <span class="id" title="tactic">reflexivity</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">right</span>. <span class="id" title="tactic">exists</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">exists</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">s</span><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <span class="id" title="var">om</span><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>. <span class="id" title="tactic">exists</span> <span class="id" title="var">om'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">split</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exists</span> <span class="id" title="var">_om</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exists</span> <span class="id" title="var">_s</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [[[<span class="id" title="var">s</span> <span class="id" title="var">His</span>] <span class="id" title="var">Heq</span>] | [<span class="id" title="var">l</span> [[<span class="id" title="var">s</span> <span class="id" title="var">om</span>] [<span class="id" title="var">om'</span> [[[<span class="id" title="var">_om</span> <span class="id" title="var">Hps</span>] [[<span class="id" title="var">_s</span> <span class="id" title="var">Hpm</span>] <span class="id" title="var">Hv</span>]] <span class="id" title="var">Ht</span>]]]]]; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exists</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a>. <span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_initial_state"><span class="id" title="constructor">protocol_initial_state</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exists</span> <span class="id" title="var">om'</span>. <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">Ht</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_generated"><span class="id" title="constructor">protocol_generated</span></a> <span class="id" title="keyword">with</span> <span class="id" title="var">_om</span> <span class="id" title="var">_s</span>; <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Protocol&nbsp;message&nbsp;characterization&nbsp;-&nbsp;similar&nbsp;to&nbsp;the&nbsp;definition&nbsp;in&nbsp;the&nbsp;report.&nbsp;*)</span><br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="protocol_message_prop_iff"><span class="id" title="lemma">protocol_message_prop_iff</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">m'</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_message_prop"><span class="id" title="definition">protocol_message_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#m'"><span class="id" title="variable">m'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#4bfb4f2d0721ba668e3a802ab1b745a1"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#f031fe1957c4a4a8e217aa46af2b4e25"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <span class="id" title="var">im</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#initial_message"><span class="id" title="method">initial_message</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#m'"><span class="id" title="variable">m'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#proj1_sig"><span class="id" title="definition">proj1_sig</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#im"><span class="id" title="variable">im</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#f031fe1957c4a4a8e217aa46af2b4e25"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#f031fe1957c4a4a8e217aa46af2b4e25"><span class="id" title="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">(</span></a><span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>) (<span class="id" title="var">som</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">*</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>) (<span class="id" title="var">s'</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">),</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition"><span class="id" title="definition">protocol_transition</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#som"><span class="id" title="variable">som</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s'"><span class="id" title="variable">s'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#m'"><span class="id" title="variable">m'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [<span class="id" title="var">s'</span> <span class="id" title="var">Hpm'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">Hpm'</span>; <span class="id" title="tactic">subst</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; <span class="id" title="tactic">try</span> (<span class="id" title="tactic">left</span>; <span class="id" title="tactic">exists</span> <span class="id" title="var">im</span>; <span class="id" title="tactic">reflexivity</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">right</span>. <span class="id" title="tactic">exists</span> <span class="id" title="var">l</span>. <span class="id" title="tactic">exists</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">s</span><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <span class="id" title="var">om</span><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>. <span class="id" title="tactic">exists</span> <span class="id" title="var">s'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">split</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exists</span> <span class="id" title="var">_om</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exists</span> <span class="id" title="var">_s</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [[[<span class="id" title="var">s</span> <span class="id" title="var">His</span>] <span class="id" title="var">Heq</span>] | [<span class="id" title="var">l</span> [[<span class="id" title="var">s</span> <span class="id" title="var">om</span>] [<span class="id" title="var">s'</span> [[[<span class="id" title="var">_om</span> <span class="id" title="var">Hps</span>] [[<span class="id" title="var">_s</span> <span class="id" title="var">Hpm</span>] <span class="id" title="var">Hv</span>]] <span class="id" title="var">Ht</span>]]]]]; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exists</span> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#proj1_sig"><span class="id" title="definition">proj1_sig</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s0"><span class="id" title="method">s0</span></a>). <span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_initial_message"><span class="id" title="constructor">protocol_initial_message</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exists</span> <span class="id" title="var">s'</span>. <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">Ht</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_generated"><span class="id" title="constructor">protocol_generated</span></a> <span class="id" title="keyword">with</span> <span class="id" title="var">_om</span> <span class="id" title="var">_s</span>; <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab8"></a><h1 class="section">Traces</h1>


<div class="paragraph"> </div>

We introduce the concept of a trace to formalize an execution of the protocol.
It is abstracted as a pair <tt>(start, steps)</tt> where <tt>start</tt> is a state
and <tt>steps</tt> is a tuple of objects which fully describe the transitions
underwent during execution. Notably, <tt>steps</tt> might be infinite.

<div class="paragraph"> </div>

In Coq, we can define these objects (which we name <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a></span>s) as consisting of:
<ul class="doclist">
<li> the <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="projection">label</span></a></span> <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="projection">l</span></a></span>

</li>
<li> the (optional) <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#input"><span class="id" title="projection">input</span></a></span> <tt>message</tt>
<div class="paragraph"> </div>


</li>
<li> the <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a></span> <span class="inlinecode"><a class="idref" href="CasperCBC.CBC.Protocol.html#state"><span class="id" title="projection">state</span></a></span> of the transition

</li>
<li> the (optional) <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#output"><span class="id" title="projection">output</span></a></span> <tt>message</tt> generated by the transition

<div class="paragraph"> </div>


</li>
</ul>

</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Record</span> <a name="transition_item"><span class="id" title="record">transition_item</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{   <a name="l"><span class="id" title="projection">l</span></a> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;   <a name="input"><span class="id" title="projection">input</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;   <a name="destination"><span class="id" title="projection">destination</span></a> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;   <a name="output"><span class="id" title="projection">output</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}.<br/>

<br/>
</div>

<div class="doc">
Note that it is unnecessary to specify the source state of the transition,
as it is implied by the preceding <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a></span> (or by the <tt>start</tt> state,
if such an item doesn't exist).

<div class="paragraph"> </div>


<div class="paragraph"> </div>

We will now split our groundwork for defining traces into the finite case and
the infinite case.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<a name="lab9"></a><h2 class="section">Finite <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace"><span class="id" title="definition">protocol_trace</span></a></span>s</h2>


<div class="paragraph"> </div>

A <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a></span> a <span class="inlinecode"><a class="idref" href="CasperCBC.CBC.Protocol.html#state"><span class="id" title="projection">state</span></a></span> <tt>start</tt> is a pair <tt>(start, steps)</tt> where <tt>steps</tt>
<div class="paragraph"> </div>

is a list of <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a></span>s, and is inductively defined by:
<ul class="doclist">
<li> <tt>(s, [])</tt> is a <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a></span> <tt>s</tt>
<div class="paragraph"> </div>


</li>
<li> if there is a <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition"><span class="id" title="definition">protocol_transition</span></a></span> <tt>l (s', iom) (s, oom)</tt>
<div class="paragraph"> </div>

  and if <tt>(s,steps)</tt> is a <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace_from"><span class="id" title="lemma">protocol_trace_from</span></a></span> <tt>s</tt>
<div class="paragraph"> </div>

  then <tt>(s', ({| l := l; input := iom; destination := s; output := oom |} :: steps)</tt>
<div class="paragraph"> </div>

  is a <span class="inlinecode"><span class="id" title="var">protocol_transition_from</span></span> <tt>s'</tt>.

<div class="paragraph"> </div>

Note that the definition is given such that it extends an existing trace by
adding a transition to its front.
The reason for this choice is to have this definition be similar to the one
for infinite traces, which can only be extended at the front.

</li>
</ul>

</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <a name="finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="finite_ptrace_empty"><span class="id" title="constructor">finite_ptrace_empty</span></a> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>), <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_state_prop"><span class="id" title="definition">protocol_state_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#ae9a5e1034e143b218b09d8e454472bd"><span class="id" title="notation">[]</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="finite_ptrace_extend"><span class="id" title="constructor">finite_ptrace_extend</span></a> : <span class="id" title="keyword">forall</span>  (<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>) (<span class="id" title="var">tl</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tl"><span class="id" title="variable">tl</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">s'</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>) (<span class="id" title="var">iom</span> <span class="id" title="var">oom</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>) (<span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition"><span class="id" title="definition">protocol_transition</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s'"><span class="id" title="variable">s'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#iom"><span class="id" title="variable">iom</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#oom"><span class="id" title="variable">oom</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a>  <a class="idref" href="CasperCBC.VLSM.Common.html#s'"><span class="id" title="variable">s'</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#cbcf67aac0c2a85b8d93d37de9969adf"><span class="id" title="notation">{|</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">l</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">l</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">input</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">iom</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">destination</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">s</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">output</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">oom</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#cbcf67aac0c2a85b8d93d37de9969adf"><span class="id" title="notation">|}</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#cbcf67aac0c2a85b8d93d37de9969adf"><span class="id" title="notation">::</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tl"><span class="id" title="variable">tl</span></a>).<br/>

<br/>
</div>

<div class="doc">
To complete our definition of a finite protocol trace, we must also guarantee that <tt>start</tt> is an
initial state according to the protocol.

</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="finite_protocol_trace"><span class="id" title="definition">finite_protocol_trace</span></a> (<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>) (<span class="id" title="var">ls</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls"><span class="id" title="variable">ls</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">/\</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#initial_state_prop"><span class="id" title="method">initial_state_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a>.<br/>

<br/>
</div>

<div class="doc">
In the remainder of the section we provide various results allowing us to
decompose the above properties in proofs.

</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="finite_ptrace_first_valid_transition"><span class="id" title="lemma">finite_ptrace_first_valid_transition</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">tr</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">te</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Htr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> (<a class="idref" href="CasperCBC.VLSM.Common.html#te"><span class="id" title="variable">te</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#cbcf67aac0c2a85b8d93d37de9969adf"><span class="id" title="notation">::</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition"><span class="id" title="definition">protocol_transition</span></a> (<a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="projection">l</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#te"><span class="id" title="variable">te</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#input"><span class="id" title="projection">input</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#te"><span class="id" title="variable">te</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#te"><span class="id" title="variable">te</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#output"><span class="id" title="projection">output</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#te"><span class="id" title="variable">te</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">Htr</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="finite_ptrace_first_pstate"><span class="id" title="lemma">finite_ptrace_first_pstate</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">tr</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Htr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_state_prop"><span class="id" title="definition">protocol_state_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">Htr</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">H0</span> <span class="id" title="keyword">as</span> [[<span class="id" title="var">Hs</span> <span class="id" title="var">_</span>] <span class="id" title="var">_</span>]. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="finite_ptrace_tail"><span class="id" title="lemma">finite_ptrace_tail</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">tr</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">te</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Htr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> (<a class="idref" href="CasperCBC.VLSM.Common.html#te"><span class="id" title="variable">te</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#cbcf67aac0c2a85b8d93d37de9969adf"><span class="id" title="notation">::</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> (<a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#te"><span class="id" title="variable">te</span></a>) <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">Htr</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="finite_ptrace_consecutive_valid_transition"><span class="id" title="lemma">finite_ptrace_consecutive_valid_transition</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">tr</span> <span class="id" title="var">tr2</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">tr1</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">te1</span> <span class="id" title="var">te2</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Htr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Heq</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr1"><span class="id" title="variable">tr1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">[</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#te1"><span class="id" title="variable">te1</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#te2"><span class="id" title="variable">te2</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">]</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr2"><span class="id" title="variable">tr2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition"><span class="id" title="definition">protocol_transition</span></a> (<a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="projection">l</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#te2"><span class="id" title="variable">te2</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#te1"><span class="id" title="variable">te1</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#input"><span class="id" title="projection">input</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#te2"><span class="id" title="variable">te2</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#te2"><span class="id" title="variable">te2</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#output"><span class="id" title="projection">output</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#te2"><span class="id" title="variable">te2</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">s</span>. <span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">tr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">tr1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">tr</span> <span class="id" title="var">Heq</span> <span class="id" title="var">s</span> <span class="id" title="var">Htr</span>. <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Heq</span>; <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">Htr</span>; <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H2</span>; <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">specialize</span> (<span class="id" title="var">IHtr1</span> (<span class="id" title="var">tr1</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">[</span></a><span class="id" title="var">te1</span><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">;</span></a> <span class="id" title="var">te2</span><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">]</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <span class="id" title="var">tr2</span>) <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">tr</span> <span class="id" title="var">Heq</span> <span class="id" title="keyword">is</span> <span class="id" title="var">Htr</span>; <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">Htr</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">IHtr1</span>. <span class="id" title="tactic">specialize</span> (<span class="id" title="var">IHtr1</span> <span class="id" title="var">s</span> <span class="id" title="var">H2</span>). <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="extend_right_finite_trace_from"><span class="id" title="lemma">extend_right_finite_trace_from</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="var">s1</span> <span class="id" title="var">ts</span> <span class="id" title="var">s3</span> <span class="id" title="var">iom3</span> <span class="id" title="var">oom3</span> <span class="id" title="var">l3</span> (<span class="id" title="var">s2</span> := <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#last"><span class="id" title="definition">List.last</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map"><span class="id" title="definition">List.map</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ts"><span class="id" title="variable">ts</span></a>) <a class="idref" href="CasperCBC.VLSM.Common.html#s1"><span class="id" title="variable">s1</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s1"><span class="id" title="variable">s1</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ts"><span class="id" title="variable">ts</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition"><span class="id" title="definition">protocol_transition</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l3"><span class="id" title="variable">l3</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s2"><span class="id" title="variable">s2</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#iom3"><span class="id" title="variable">iom3</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s3"><span class="id" title="variable">s3</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#oom3"><span class="id" title="variable">oom3</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s1"><span class="id" title="variable">s1</span></a> (<a class="idref" href="CasperCBC.VLSM.Common.html#ts"><span class="id" title="variable">ts</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#ddd65c2f7ee73ecec433744948d846bb"><span class="id" title="notation">[{|</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">l</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">l3</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">destination</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">s3</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">input</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">iom3</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">output</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">oom3</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#ddd65c2f7ee73ecec433744948d846bb"><span class="id" title="notation">|}]</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">s1</span> <span class="id" title="var">ts</span> <span class="id" title="var">s3</span> <span class="id" title="var">iom3</span> <span class="id" title="var">oom3</span> <span class="id" title="var">l3</span> <span class="id" title="var">s2</span> <span class="id" title="var">Ht12</span> <span class="id" title="var">Hv23</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">Ht12</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#finite_ptrace_extend"><span class="id" title="constructor">finite_ptrace_extend</span></a>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">apply</span> (<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition_destination"><span class="id" title="lemma">protocol_transition_destination</span></a> <span class="id" title="var">Hv23</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">rewrite</span> &lt;- <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#app_comm_cons"><span class="id" title="lemma">app_comm_cons</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#finite_ptrace_extend"><span class="id" title="constructor">finite_ptrace_extend</span></a>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">IHHt12</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">IHHt12</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">s2</span> <span class="id" title="tactic">in</span> *; <span class="id" title="tactic">clear</span> <span class="id" title="var">s2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">replace</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#last"><span class="id" title="definition">last</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map"><span class="id" title="definition">List.map</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> <span class="id" title="var">tl</span>) <span class="id" title="var">s</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#last"><span class="id" title="definition">last</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map"><span class="id" title="definition">List.map</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#cbcf67aac0c2a85b8d93d37de9969adf"><span class="id" title="notation">{|</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">l</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">l1</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">input</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">iom</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">destination</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">s</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">output</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">oom</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#cbcf67aac0c2a85b8d93d37de9969adf"><span class="id" title="notation">|}</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#cbcf67aac0c2a85b8d93d37de9969adf"><span class="id" title="notation">::</span></a> <span class="id" title="var">tl</span>)) <span class="id" title="var">s'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; <span class="id" title="tactic">try</span> <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map_cons"><span class="id" title="lemma">map_cons</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">tl</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map_cons"><span class="id" title="lemma">map_cons</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">eapply</span> <a class="idref" href="CasperCBC.Lib.ListExtras.html#remove_hd_last"><span class="id" title="lemma">remove_hd_last</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
We can now prove several general properties of <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace"><span class="id" title="definition">finite_protocol_trace</span></a></span>s. For example,
the following lemma states that given two such traces, such that the latter's starting state
is equal to the former's last state, it is possible to <i>concatenate</i> them into a single
<span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace"><span class="id" title="definition">finite_protocol_trace</span></a></span>.

</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="finite_protocol_trace_from_app_iff"><span class="id" title="lemma">finite_protocol_trace_from_app_iff</span></a> (<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>) (<span class="id" title="var">ls</span> <span class="id" title="var">ls'</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>) (<span class="id" title="var">s'</span> := (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#last"><span class="id" title="definition">last</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map"><span class="id" title="definition">List.map</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls"><span class="id" title="variable">ls</span></a>) <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls"><span class="id" title="variable">ls</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">/\</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s'"><span class="id" title="variable">s'</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls'"><span class="id" title="variable">ls'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#4bfb4f2d0721ba668e3a802ab1b745a1"><span class="id" title="notation">&lt;-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> (<a class="idref" href="CasperCBC.VLSM.Common.html#ls"><span class="id" title="variable">ls</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls'"><span class="id" title="variable">ls'</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">ls'</span>. <span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">ls</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [<span class="id" title="var">_</span> <span class="id" title="var">H</span>]. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">split</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">assumption</span>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition_origin"><span class="id" title="lemma">protocol_transition_origin</span></a> <span class="id" title="var">H1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> [<span class="id" title="var">Htr</span> <span class="id" title="var">Htr'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#finite_ptrace_extend"><span class="id" title="constructor">finite_ptrace_extend</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">IHls</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">Htr</span>. <span class="id" title="tactic">split</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">s'</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Htr'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">last_identity</span>: <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#last"><span class="id" title="definition">last</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map"><span class="id" title="definition">List.map</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> <span class="id" title="var">ls</span>) <span class="id" title="var">destination0</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#last"><span class="id" title="definition">last</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map"><span class="id" title="definition">List.map</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#cbcf67aac0c2a85b8d93d37de9969adf"><span class="id" title="notation">{|</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">l</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">l1</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">input</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">input0</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">destination</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">destination0</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">output</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">output0</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#cbcf67aac0c2a85b8d93d37de9969adf"><span class="id" title="notation">|}</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#cbcf67aac0c2a85b8d93d37de9969adf"><span class="id" title="notation">::</span></a> <span class="id" title="var">ls</span>)) <span class="id" title="var">s</span>). {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map_cons"><span class="id" title="lemma">map_cons</span></a>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="CasperCBC.Lib.ListExtras.html#unroll_last"><span class="id" title="lemma">unroll_last</span></a>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">last_identity</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">inversion</span> <span class="id" title="var">Htr</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H6</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">specialize</span> (<span class="id" title="var">IHls</span> <span class="id" title="var">s1</span>). <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">IHls</span>. <span class="id" title="tactic">specialize</span> (<span class="id" title="var">IHls</span> <span class="id" title="var">ls'</span>). <span class="id" title="tactic">apply</span> <span class="id" title="var">IHls</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">H3</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H0</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H4</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">assert</span> (<span class="id" title="var">last_identity</span> : <span class="id" title="var">s'</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#last"><span class="id" title="definition">last</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map"><span class="id" title="definition">List.map</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> <span class="id" title="var">ls</span>) <span class="id" title="var">s1</span>). {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">s'</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map_cons"><span class="id" title="lemma">map_cons</span></a>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="CasperCBC.Lib.ListExtras.html#unroll_last"><span class="id" title="lemma">unroll_last</span></a>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">last_identity</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Several other lemmas in this vein are necessary for proving results regarding
traces.

</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="finite_protocol_trace_from_prefix"><span class="id" title="lemma">finite_protocol_trace_from_prefix</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ls</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Htr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls"><span class="id" title="variable">ls</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> (<a class="idref" href="CasperCBC.Lib.ListExtras.html#list_prefix"><span class="id" title="definition">list_prefix</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls"><span class="id" title="variable">ls</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#n"><span class="id" title="variable">n</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<a class="idref" href="CasperCBC.Lib.ListExtras.html#list_prefix_suffix"><span class="id" title="lemma">list_prefix_suffix</span></a> <span class="id" title="var">ls</span> <span class="id" title="var">n</span>); <span class="id" title="tactic">intro</span> <span class="id" title="var">Hdecompose</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">Hdecompose</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Htr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from_app_iff"><span class="id" title="lemma">finite_protocol_trace_from_app_iff</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">Htr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Htr</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Hpr</span> <span class="id" title="var">_</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="finite_protocol_trace_from_suffix"><span class="id" title="lemma">finite_protocol_trace_from_suffix</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ls</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Htr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls"><span class="id" title="variable">ls</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">nth</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Hnth</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#nth_error"><span class="id" title="definition">nth_error</span></a> (<a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#cbcf67aac0c2a85b8d93d37de9969adf"><span class="id" title="notation">::</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map"><span class="id" title="definition">List.map</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls"><span class="id" title="variable">ls</span></a>) <a class="idref" href="CasperCBC.VLSM.Common.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#nth"><span class="id" title="variable">nth</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#nth"><span class="id" title="variable">nth</span></a> (<a class="idref" href="CasperCBC.Lib.ListExtras.html#list_suffix"><span class="id" title="definition">list_suffix</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls"><span class="id" title="variable">ls</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#n"><span class="id" title="variable">n</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<a class="idref" href="CasperCBC.Lib.ListExtras.html#list_prefix_suffix"><span class="id" title="lemma">list_prefix_suffix</span></a> <span class="id" title="var">ls</span> <span class="id" title="var">n</span>); <span class="id" title="tactic">intro</span> <span class="id" title="var">Hdecompose</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">Hdecompose</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Htr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from_app_iff"><span class="id" title="lemma">finite_protocol_trace_from_app_iff</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">Htr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Htr</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">_</span> <span class="id" title="var">Htr</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">Heq</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#last"><span class="id" title="definition">last</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map"><span class="id" title="definition">List.map</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> (<a class="idref" href="CasperCBC.Lib.ListExtras.html#list_prefix"><span class="id" title="definition">list_prefix</span></a> <span class="id" title="var">ls</span> <span class="id" title="var">n</span>)) <span class="id" title="var">s</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="var">nth</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">rewrite</span> <a class="idref" href="CasperCBC.Lib.ListExtras.html#list_prefix_map"><span class="id" title="lemma">list_prefix_map</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Hnth</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">Hnth</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">clear</span> <span class="id" title="var">Hnth</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">remember</span> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map"><span class="id" title="definition">List.map</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> <span class="id" title="var">ls</span>) <span class="id" title="keyword">as</span> <span class="id" title="var">l</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">l</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">symmetry</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.Lib.ListExtras.html#list_prefix_nth_last"><span class="id" title="lemma">list_prefix_nth_last</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Hnth</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">Heq</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Htr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="finite_protocol_trace_from_segment"><span class="id" title="lemma">finite_protocol_trace_from_segment</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ls</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Htr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls"><span class="id" title="variable">ls</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">n1</span> <span class="id" title="var">n2</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Hle</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#n1"><span class="id" title="variable">n1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano.html#cb53cf0ee22c036a03b4a9281c68b5a3"><span class="id" title="notation">&lt;=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#n2"><span class="id" title="variable">n2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">n1th</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Hnth</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#nth_error"><span class="id" title="definition">nth_error</span></a> (<a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#cbcf67aac0c2a85b8d93d37de9969adf"><span class="id" title="notation">::</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map"><span class="id" title="definition">List.map</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls"><span class="id" title="variable">ls</span></a>) <a class="idref" href="CasperCBC.VLSM.Common.html#n1"><span class="id" title="variable">n1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#n1th"><span class="id" title="variable">n1th</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#n1th"><span class="id" title="variable">n1th</span></a> (<a class="idref" href="CasperCBC.Lib.ListExtras.html#list_segment"><span class="id" title="definition">list_segment</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls"><span class="id" title="variable">ls</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#n1"><span class="id" title="variable">n1</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#n2"><span class="id" title="variable">n2</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from_suffix"><span class="id" title="lemma">finite_protocol_trace_from_suffix</span></a> <span class="id" title="keyword">with</span> <span class="id" title="var">s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from_prefix"><span class="id" title="lemma">finite_protocol_trace_from_prefix</span></a>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">n1</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Hnth</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="CasperCBC.Lib.ListExtras.html#list_prefix_map"><span class="id" title="lemma">list_prefix_map</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="CasperCBC.Lib.ListExtras.html#list_prefix_nth"><span class="id" title="lemma">list_prefix_nth</span></a>; <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab10"></a><h2 class="section">Infinite <span class="inlinecode"><span class="id" title="var">protcol_trace</span></span>s</h2>


<div class="paragraph"> </div>

 We now define <span class="inlinecode"><span class="id" title="var">infinite_protocol_trace</span></span>s. The definitions
resemble their finite counterparts, adapted to the technical
necessities of defining infinite objects. Notably, <tt>steps</tt> is
stored as a stream, as opposed to a list.

</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">CoInductive</span> <a name="infinite_protocol_trace_from"><span class="id" title="inductive">infinite_protocol_trace_from</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.Streams.html#Stream"><span class="id" title="inductive">Stream</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="infinite_ptrace_extend"><span class="id" title="constructor">infinite_ptrace_extend</span></a> : <span class="id" title="keyword">forall</span>  (<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>) (<span class="id" title="var">tl</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.Streams.html#Stream"><span class="id" title="inductive">Stream</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#infinite_protocol_trace_from"><span class="id" title="inductive">infinite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tl"><span class="id" title="variable">tl</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">s'</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>) (<span class="id" title="var">iom</span> <span class="id" title="var">oom</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>) (<span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition"><span class="id" title="definition">protocol_transition</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s'"><span class="id" title="variable">s'</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#iom"><span class="id" title="variable">iom</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#oom"><span class="id" title="variable">oom</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#infinite_protocol_trace_from"><span class="id" title="inductive">infinite_protocol_trace_from</span></a>  <a class="idref" href="CasperCBC.VLSM.Common.html#s'"><span class="id" title="variable">s'</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.Streams.html#Cons"><span class="id" title="constructor">Cons</span></a> {| <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">l</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">l</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">input</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">iom</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">destination</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">s</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">output</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">oom</span></a> |}  <a class="idref" href="CasperCBC.VLSM.Common.html#tl"><span class="id" title="variable">tl</span></a>).<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="infinite_ptrace"><span class="id" title="definition">infinite_ptrace</span></a> (<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>) (<span class="id" title="var">st</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.Streams.html#Stream"><span class="id" title="inductive">Stream</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:= <a class="idref" href="CasperCBC.VLSM.Common.html#infinite_protocol_trace_from"><span class="id" title="inductive">infinite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#st"><span class="id" title="variable">st</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">/\</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#initial_state_prop"><span class="id" title="method">initial_state_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a>.<br/>

<br/>
</div>

<div class="doc">
As for the finite case, the following lemmas help decompose teh above
definitions, mostly reducing them to properties about their finite segments.

</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="infinite_ptrace_consecutive_valid_transition"><span class="id" title="lemma">infinite_ptrace_consecutive_valid_transition</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">is</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">tr</span> <span class="id" title="var">tr2</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.Streams.html#Stream"><span class="id" title="inductive">Stream</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">tr1</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">te1</span> <span class="id" title="var">te2</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Htr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#infinite_protocol_trace_from"><span class="id" title="inductive">infinite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#is"><span class="id" title="variable">is</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Heq</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="CasperCBC.Lib.StreamExtras.html#stream_app"><span class="id" title="definition">stream_app</span></a> (<a class="idref" href="CasperCBC.VLSM.Common.html#tr1"><span class="id" title="variable">tr1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">[</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#te1"><span class="id" title="variable">te1</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#te2"><span class="id" title="variable">te2</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">]</span></a>) <a class="idref" href="CasperCBC.VLSM.Common.html#tr2"><span class="id" title="variable">tr2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition"><span class="id" title="definition">protocol_transition</span></a> (<a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="projection">l</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#te2"><span class="id" title="variable">te2</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#te1"><span class="id" title="variable">te1</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#input"><span class="id" title="projection">input</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#te2"><span class="id" title="variable">te2</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#te2"><span class="id" title="variable">te2</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#output"><span class="id" title="projection">output</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#te2"><span class="id" title="variable">te2</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="keyword">is</span>. <span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">tr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">tr1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">tr</span> <span class="id" title="var">Heq</span> <span class="id" title="keyword">is</span> <span class="id" title="var">Htr</span>. <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Heq</span>; <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">Htr</span>; <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H2</span>; <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">specialize</span> (<span class="id" title="var">IHtr1</span> (<a class="idref" href="CasperCBC.Lib.StreamExtras.html#stream_app"><span class="id" title="definition">stream_app</span></a> (<span class="id" title="var">tr1</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">[</span></a><span class="id" title="var">te1</span><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">;</span></a> <span class="id" title="var">te2</span><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#e76c6291366b599375c28eba0aae94bb"><span class="id" title="notation">]</span></a>) <span class="id" title="var">tr2</span>) <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#eq_refl"><span class="id" title="constructor">eq_refl</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">tr</span> <span class="id" title="var">Heq</span> <span class="id" title="keyword">is</span> <span class="id" title="var">Htr</span>; <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">Htr</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">IHtr1</span> <span class="id" title="var">s</span> <span class="id" title="var">H2</span>). <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="infinite_protocol_trace_from_app_iff"><span class="id" title="lemma">infinite_protocol_trace_from_app_iff</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ls</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ls'</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.Streams.html#Stream"><span class="id" title="inductive">Stream</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">s'</span> := (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#last"><span class="id" title="definition">last</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map"><span class="id" title="definition">List.map</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls"><span class="id" title="variable">ls</span></a>) <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls"><span class="id" title="variable">ls</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">/\</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#infinite_protocol_trace_from"><span class="id" title="inductive">infinite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s'"><span class="id" title="variable">s'</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls'"><span class="id" title="variable">ls'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#4bfb4f2d0721ba668e3a802ab1b745a1"><span class="id" title="notation">&lt;-&gt;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#infinite_protocol_trace_from"><span class="id" title="inductive">infinite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> (<a class="idref" href="CasperCBC.Lib.StreamExtras.html#stream_app"><span class="id" title="definition">stream_app</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls"><span class="id" title="variable">ls</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls'"><span class="id" title="variable">ls'</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>. <span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">ls'</span>. <span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">ls</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [<span class="id" title="var">_</span> <span class="id" title="var">H</span>]. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">split</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">assumption</span>. <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_transition_origin"><span class="id" title="lemma">protocol_transition_origin</span></a> <span class="id" title="var">H1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">intros</span> [<span class="id" title="var">Htr</span> <span class="id" title="var">Htr'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#infinite_ptrace_extend"><span class="id" title="constructor">infinite_ptrace_extend</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">IHls</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">Htr</span>. <span class="id" title="tactic">split</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">s'</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Htr'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">last_identity</span>: <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#last"><span class="id" title="definition">last</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map"><span class="id" title="definition">List.map</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> <span class="id" title="var">ls</span>) <span class="id" title="var">destination0</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#last"><span class="id" title="definition">last</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map"><span class="id" title="definition">List.map</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#cbcf67aac0c2a85b8d93d37de9969adf"><span class="id" title="notation">{|</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">l</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">l1</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">input</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">input0</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">destination</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">destination0</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">output</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_transition_item"><span class="id" title="constructor">output0</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#cbcf67aac0c2a85b8d93d37de9969adf"><span class="id" title="notation">|}</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#cbcf67aac0c2a85b8d93d37de9969adf"><span class="id" title="notation">::</span></a> <span class="id" title="var">ls</span>)) <span class="id" title="var">s</span>). {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map_cons"><span class="id" title="lemma">map_cons</span></a>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="CasperCBC.Lib.ListExtras.html#unroll_last"><span class="id" title="lemma">unroll_last</span></a>. <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">last_identity</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">inversion</span> <span class="id" title="var">Htr</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H6</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span>. <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">specialize</span> (<span class="id" title="var">IHls</span> <span class="id" title="var">s1</span>). <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">IHls</span>. <span class="id" title="tactic">specialize</span> (<span class="id" title="var">IHls</span> <span class="id" title="var">ls'</span>). <span class="id" title="tactic">apply</span> <span class="id" title="var">IHls</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">H3</span>. <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">constructor</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H0</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">H4</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">assert</span> (<span class="id" title="var">last_identity</span> : <span class="id" title="var">s'</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#last"><span class="id" title="definition">last</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map"><span class="id" title="definition">List.map</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> <span class="id" title="var">ls</span>) <span class="id" title="var">s1</span>). {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">s'</span>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map_cons"><span class="id" title="lemma">map_cons</span></a>. <span class="id" title="tactic">rewrite</span> <a class="idref" href="CasperCBC.Lib.ListExtras.html#unroll_last"><span class="id" title="lemma">unroll_last</span></a>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">last_identity</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="infinite_protocol_trace_from_prefix"><span class="id" title="lemma">infinite_protocol_trace_from_prefix</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ls</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.Streams.html#Stream"><span class="id" title="inductive">Stream</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Htr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#infinite_protocol_trace_from"><span class="id" title="inductive">infinite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls"><span class="id" title="variable">ls</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> (<a class="idref" href="CasperCBC.Lib.StreamExtras.html#stream_prefix"><span class="id" title="definition">stream_prefix</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls"><span class="id" title="variable">ls</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#n"><span class="id" title="variable">n</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<a class="idref" href="CasperCBC.Lib.StreamExtras.html#stream_prefix_suffix"><span class="id" title="lemma">stream_prefix_suffix</span></a> <span class="id" title="var">ls</span> <span class="id" title="var">n</span>); <span class="id" title="tactic">intro</span> <span class="id" title="var">Hdecompose</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">Hdecompose</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Htr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#infinite_protocol_trace_from_app_iff"><span class="id" title="lemma">infinite_protocol_trace_from_app_iff</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">Htr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Htr</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Hpr</span> <span class="id" title="var">_</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="infinite_protocol_trace_from_prefix_rev"><span class="id" title="lemma">infinite_protocol_trace_from_prefix_rev</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ls</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.Streams.html#Stream"><span class="id" title="inductive">Stream</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Hpref</span>: <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> (<a class="idref" href="CasperCBC.Lib.StreamExtras.html#stream_prefix"><span class="id" title="definition">stream_prefix</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls"><span class="id" title="variable">ls</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#n"><span class="id" title="variable">n</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#infinite_protocol_trace_from"><span class="id" title="inductive">infinite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls"><span class="id" title="variable">ls</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">Hpref</span>. <span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">s</span>. <span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">ls</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">cofix</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> (<span class="id" title="var">a</span>, <span class="id" title="var">ls</span>) <span class="id" title="var">s</span> <span class="id" title="var">Hpref</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">Hpref0</span> := <span class="id" title="var">Hpref</span> 1).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">Hpref0</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">Hpref</span> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Hpref</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">Hpref</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="infinite_protocol_trace_from_segment"><span class="id" title="lemma">infinite_protocol_trace_from_segment</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ls</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.Streams.html#Stream"><span class="id" title="inductive">Stream</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Htr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#infinite_protocol_trace_from"><span class="id" title="inductive">infinite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls"><span class="id" title="variable">ls</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">n1</span> <span class="id" title="var">n2</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Hle</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#n1"><span class="id" title="variable">n1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Peano.html#cb53cf0ee22c036a03b4a9281c68b5a3"><span class="id" title="notation">&lt;=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#n2"><span class="id" title="variable">n2</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">n1th</span> := <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.Streams.html#Str_nth"><span class="id" title="definition">Str_nth</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#n1"><span class="id" title="variable">n1</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.Streams.html#Cons"><span class="id" title="constructor">Cons</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.Streams.html#map"><span class="id" title="definition">Streams.map</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls"><span class="id" title="variable">ls</span></a>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#n1th"><span class="id" title="variable">n1th</span></a> (<a class="idref" href="CasperCBC.Lib.StreamExtras.html#stream_segment"><span class="id" title="definition">stream_segment</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ls"><span class="id" title="variable">ls</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#n1"><span class="id" title="variable">n1</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#n2"><span class="id" title="variable">n2</span></a>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from_suffix"><span class="id" title="lemma">finite_protocol_trace_from_suffix</span></a> <span class="id" title="keyword">with</span> <span class="id" title="var">s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#infinite_protocol_trace_from_prefix"><span class="id" title="lemma">infinite_protocol_trace_from_prefix</span></a>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">n1</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">n1th</span>. <span class="id" title="tactic">clear</span> <span class="id" title="var">n1th</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="CasperCBC.Lib.StreamExtras.html#stream_prefix_map"><span class="id" title="lemma">stream_prefix_map</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="CasperCBC.Lib.StreamExtras.html#stream_prefix_nth"><span class="id" title="lemma">stream_prefix_nth</span></a>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<a name="lab11"></a><h2 class="section">Protocol traces</h2>


<div class="paragraph"> </div>

Finally, we define <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#Trace"><span class="id" title="inductive">Trace</span></a></span> as a sum-type of its finite/infinite variants.
It inherits some previously introduced definitions, culminating with the
<span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace"><span class="id" title="definition">protocol_trace</span></a></span>.

</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <a name="Trace"><span class="id" title="inductive">Trace</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Finite"><span class="id" title="constructor">Finite</span></a> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Trace"><span class="id" title="inductive">Trace</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a name="Infinite"><span class="id" title="constructor">Infinite</span></a> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.Streams.html#Stream"><span class="id" title="inductive">Stream</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Trace"><span class="id" title="inductive">Trace</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="trace_first"><span class="id" title="definition">trace_first</span></a> (<span class="id" title="var">tr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#Trace"><span class="id" title="inductive">Trace</span></a>) : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="CasperCBC.VLSM.Common.html#Finite"><span class="id" title="constructor">Finite</span></a> <span class="id" title="var">s</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">s</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="CasperCBC.VLSM.Common.html#Infinite"><span class="id" title="constructor">Infinite</span></a> <span class="id" title="var">s</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">s</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="trace_last"><span class="id" title="definition">trace_last</span></a> (<span class="id" title="var">tr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#Trace"><span class="id" title="inductive">Trace</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="CasperCBC.VLSM.Common.html#Finite"><span class="id" title="constructor">Finite</span></a> <span class="id" title="var">s</span> <span class="id" title="var">ls</span> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#last"><span class="id" title="definition">last</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map"><span class="id" title="definition">List.map</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> <span class="id" title="var">ls</span>) <span class="id" title="var">s</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="CasperCBC.VLSM.Common.html#Infinite"><span class="id" title="constructor">Infinite</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="ptrace_from_prop"><span class="id" title="definition">ptrace_from_prop</span></a> (<span class="id" title="var">tr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#Trace"><span class="id" title="inductive">Trace</span></a>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="CasperCBC.VLSM.Common.html#Finite"><span class="id" title="constructor">Finite</span></a> <span class="id" title="var">s</span> <span class="id" title="var">ls</span> =&gt; <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <span class="id" title="var">s</span> <span class="id" title="var">ls</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="CasperCBC.VLSM.Common.html#Infinite"><span class="id" title="constructor">Infinite</span></a> <span class="id" title="var">s</span> <span class="id" title="var">sm</span> =&gt; <a class="idref" href="CasperCBC.VLSM.Common.html#infinite_protocol_trace_from"><span class="id" title="inductive">infinite_protocol_trace_from</span></a> <span class="id" title="var">s</span> <span class="id" title="var">sm</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="protocol_trace_prop"><span class="id" title="definition">protocol_trace_prop</span></a> (<span class="id" title="var">tr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#Trace"><span class="id" title="inductive">Trace</span></a>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="CasperCBC.VLSM.Common.html#Finite"><span class="id" title="constructor">Finite</span></a> <span class="id" title="var">s</span> <span class="id" title="var">ls</span> =&gt; <a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace"><span class="id" title="definition">finite_protocol_trace</span></a> <span class="id" title="var">s</span> <span class="id" title="var">ls</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="CasperCBC.VLSM.Common.html#Infinite"><span class="id" title="constructor">Infinite</span></a> <span class="id" title="var">s</span> <span class="id" title="var">sm</span> =&gt; <a class="idref" href="CasperCBC.VLSM.Common.html#infinite_ptrace"><span class="id" title="definition">infinite_ptrace</span></a> <span class="id" title="var">s</span> <span class="id" title="var">sm</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="protocol_trace"><span class="id" title="definition">protocol_trace</span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">{</span></a> <span class="id" title="var">tr</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">:</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Trace"><span class="id" title="inductive">Trace</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">|</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace_prop"><span class="id" title="definition">protocol_trace_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#6556914db359db999889decec6a4a562"><span class="id" title="notation">}</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="protocol_trace_from"><span class="id" title="lemma">protocol_trace_from</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">tr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#Trace"><span class="id" title="inductive">Trace</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Htr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace_prop"><span class="id" title="definition">protocol_trace_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#ptrace_from_prop"><span class="id" title="definition">ptrace_from_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">tr</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">Htr</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Htr</span> <span class="id" title="var">Hinit</span>]; <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="protocol_trace_initial"><span class="id" title="lemma">protocol_trace_initial</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">tr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#Trace"><span class="id" title="inductive">Trace</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Htr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace_prop"><span class="id" title="definition">protocol_trace_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#initial_state_prop"><span class="id" title="method">initial_state_prop</span></a> (<a class="idref" href="CasperCBC.VLSM.Common.html#trace_first"><span class="id" title="definition">trace_first</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">tr</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">Htr</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">Htr</span> <span class="id" title="var">Hinit</span>]; <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="protocol_trace_from_iff"><span class="id" title="lemma">protocol_trace_from_iff</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">tr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#Trace"><span class="id" title="inductive">Trace</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace_prop"><span class="id" title="definition">protocol_trace_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#4bfb4f2d0721ba668e3a802ab1b745a1"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#ptrace_from_prop"><span class="id" title="definition">ptrace_from_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">/\</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#initial_state_prop"><span class="id" title="method">initial_state_prop</span></a> (<a class="idref" href="CasperCBC.VLSM.Common.html#trace_first"><span class="id" title="definition">trace_first</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intro</span> <span class="id" title="var">Htr</span>; <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace_from"><span class="id" title="lemma">protocol_trace_from</span></a>; <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace_initial"><span class="id" title="lemma">protocol_trace_initial</span></a>; <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">tr</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intros</span> [<span class="id" title="var">Htr</span> <span class="id" title="var">Hinit</span>]; <span class="id" title="tactic">split</span>; <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
Having defined <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace"><span class="id" title="definition">protocol_trace</span></a></span>s, we now connect them to protocol states
and messages, in the following sense: for each state-message pair (<tt>s</tt>, <tt>m</tt>)
that has the <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_prop"><span class="id" title="inductive">protocol_prop</span></a></span>erty, there exists a <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace"><span class="id" title="definition">protocol_trace</span></a></span> which ends
in <tt>s</tt> by outputting <tt>m</tt> 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="protocol_is_trace"><span class="id" title="lemma">protocol_is_trace</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">om</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM.message"><span class="id" title="variable">message</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Hp</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_prop"><span class="id" title="inductive">protocol_prop</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#initial_state_prop"><span class="id" title="method">initial_state_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#f031fe1957c4a4a8e217aa46af2b4e25"><span class="id" title="notation">\/</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">(</span></a><span class="id" title="keyword">is</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>) (<span class="id" title="var">tr</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">),</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace"><span class="id" title="definition">finite_protocol_trace</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#is"><span class="id" title="variable">is</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">/\</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option_map"><span class="id" title="definition">option_map</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> (<a class="idref" href="CasperCBC.Lib.ListExtras.html#last_error"><span class="id" title="definition">last_error</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">/\</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option_map"><span class="id" title="definition">option_map</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#output"><span class="id" title="projection">output</span></a> (<a class="idref" href="CasperCBC.Lib.ListExtras.html#last_error"><span class="id" title="definition">last_error</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_is_run"><span class="id" title="lemma">protocol_is_run</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><span class="id" title="var">s</span><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a><span class="id" title="var">om</span><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> <span class="id" title="var">Hp</span>); <span class="id" title="tactic">intros</span> [<span class="id" title="var">vr</span> <span class="id" title="var">Heq</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<a class="idref" href="CasperCBC.VLSM.Common.html#run_is_trace"><span class="id" title="lemma">run_is_trace</span></a> <span class="id" title="var">vr</span>); <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">Htr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">vr</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">r</span> <span class="id" title="var">Hvr</span>]; <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> *.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<a class="idref" href="CasperCBC.VLSM.Common.html#transitions"><span class="id" title="projection">transitions</span></a> <span class="id" title="var">r</span>) <span class="id" title="var">eqn</span>:<span class="id" title="var">Htrace</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">inversion</span> <span class="id" title="var">Hvr</span>; <span class="id" title="tactic">subst</span>; <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Htrace</span>; <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Heq</span>; <span class="id" title="tactic">inversion</span> <span class="id" title="var">Heq</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">destruct</span> <span class="id" title="keyword">is</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">s0</span> <span class="id" title="var">His</span>]. <span class="id" title="tactic">left</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">destruct</span> <a class="idref" href="CasperCBC.VLSM.Common.html#s0"><span class="id" title="method">s0</span></a> <span class="id" title="keyword">as</span> [<span class="id" title="var">s0</span> <span class="id" title="var">His</span>]. <span class="id" title="tactic">left</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">destruct</span> <span class="id" title="var">ts</span>; <span class="id" title="tactic">inversion</span> <span class="id" title="var">Htrace</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">right</span>. <span class="id" title="tactic">exists</span> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#proj1_sig"><span class="id" title="definition">proj1_sig</span></a> (<a class="idref" href="CasperCBC.VLSM.Common.html#start"><span class="id" title="projection">start</span></a> <span class="id" title="var">r</span>)). <span class="id" title="tactic">exists</span> (<a class="idref" href="CasperCBC.VLSM.Common.html#transitions"><span class="id" title="projection">transitions</span></a> <span class="id" title="var">r</span>). <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Htrace</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">split</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<a class="idref" href="CasperCBC.VLSM.Common.html#vlsm_run_last_final"><span class="id" title="lemma">vlsm_run_last_final</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#exist"><span class="id" title="constructor">exist</span></a> <span class="id" title="var">_</span> <span class="id" title="var">r</span> <span class="id" title="var">Hvr</span>)); <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Htrace</span>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">Heq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">Hlf</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">Hlf</span>. <span class="id" title="tactic">intros</span> <span class="id" title="var">HC</span>; <span class="id" title="tactic">inversion</span> <span class="id" title="var">HC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Next function extract the nth state of a trace, where the sequence of
states of a trace is obtained by appending the all destination
states in the transition list/stream to the initial state of the trace.

</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="trace_nth"><span class="id" title="definition">trace_nth</span></a> (<span class="id" title="var">tr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#Trace"><span class="id" title="inductive">Trace</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="CasperCBC.VLSM.Common.html#Finite"><span class="id" title="constructor">Finite</span></a> <span class="id" title="var">s</span> <span class="id" title="var">ls</span> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#nth_error"><span class="id" title="definition">nth_error</span></a> (<span class="id" title="var">s</span><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#cbcf67aac0c2a85b8d93d37de9969adf"><span class="id" title="notation">::</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map"><span class="id" title="definition">List.map</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> <span class="id" title="var">ls</span>) <a class="idref" href="CasperCBC.VLSM.Common.html#n"><span class="id" title="variable">n</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="CasperCBC.VLSM.Common.html#Infinite"><span class="id" title="constructor">Infinite</span></a> <span class="id" title="var">s</span> <span class="id" title="var">st</span> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.Streams.html#Str_nth"><span class="id" title="definition">Str_nth</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#n"><span class="id" title="variable">n</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.Streams.html#Cons"><span class="id" title="constructor">Cons</span></a> <span class="id" title="var">s</span> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.Streams.html#map"><span class="id" title="definition">Streams.map</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> <span class="id" title="var">st</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Another benefit of defining traces is that we can succintly
describe indirect transitions between arbitrary pairs of states.

<div class="paragraph"> </div>

We say that state <tt>second</tt> is in state <tt>first</tt>'s futures if
there exists a finite (possibly empty) protocol trace that begins
with <tt>first</tt> and ends in <tt>second</tt>.

<div class="paragraph"> </div>

This relation is often used in stating safety and liveness properties.
</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="in_futures"><span class="id" title="definition">in_futures</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">first</span> <span class="id" title="var">second</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">(</span></a><span class="id" title="var">tr</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">),</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#finite_protocol_trace_from"><span class="id" title="inductive">finite_protocol_trace_from</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#first"><span class="id" title="variable">first</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">/\</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#last"><span class="id" title="definition">last</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Lists.List.html#map"><span class="id" title="definition">List.map</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#destination"><span class="id" title="projection">destination</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a>) <a class="idref" href="CasperCBC.VLSM.Common.html#first"><span class="id" title="variable">first</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#second"><span class="id" title="variable">second</span></a>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="in_futures_protocol_fst"><span class="id" title="lemma">in_futures_protocol_fst</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">first</span> <span class="id" title="var">second</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Hfuture</span>: <a class="idref" href="CasperCBC.VLSM.Common.html#in_futures"><span class="id" title="definition">in_futures</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#first"><span class="id" title="variable">first</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#second"><span class="id" title="variable">second</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_state_prop"><span class="id" title="definition">protocol_state_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#first"><span class="id" title="variable">first</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">Hfuture</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">tr</span> [<span class="id" title="var">Htr</span> <span class="id" title="var">Hlast</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#finite_ptrace_first_pstate"><span class="id" title="lemma">finite_ptrace_first_pstate</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">Htr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
Stating livness properties will require quantifying over complete
executions of the protocol. To make this possible, we will now define
<i>complete</i> <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace"><span class="id" title="definition">protocol_trace</span></a></span>s.

<div class="paragraph"> </div>

A <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace"><span class="id" title="definition">protocol_trace</span></a></span> is <i>terminating</i> if there's no other <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace"><span class="id" title="definition">protocol_trace</span></a></span>
that contains it as a prefix.

</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="terminating_trace_prop"><span class="id" title="definition">terminating_trace_prop</span></a> (<span class="id" title="var">tr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#Trace"><span class="id" title="inductive">Trace</span></a>) : <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="CasperCBC.VLSM.Common.html#Finite"><span class="id" title="constructor">Finite</span></a> <span class="id" title="var">s</span> <span class="id" title="var">ls</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">(</span></a><span class="id" title="var">tr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace"><span class="id" title="definition">protocol_trace</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">last</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#transition_item"><span class="id" title="record">transition_item</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">),</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#trace_prefix"><span class="id" title="definition">trace_prefix</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Specif.html#proj1_sig"><span class="id" title="definition">proj1_sig</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a>) <a class="idref" href="CasperCBC.VLSM.Common.html#last"><span class="id" title="variable">last</span></a> <span class="id" title="var">ls</span><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="CasperCBC.VLSM.Common.html#Infinite"><span class="id" title="constructor">Infinite</span></a> <span class="id" title="var">s</span> <span class="id" title="var">ls</span> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
A <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace"><span class="id" title="definition">protocol_trace</span></a></span> is <i>complete</i>, if it is either <i>terminating</i> or infinite.

</div>
<div class="code">

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="complete_trace_prop"><span class="id" title="definition">complete_trace_prop</span></a> (<span class="id" title="var">tr</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#Trace"><span class="id" title="inductive">Trace</span></a>) : <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:= <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace_prop"><span class="id" title="definition">protocol_trace_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">/\</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="CasperCBC.VLSM.Common.html#Finite"><span class="id" title="constructor">Finite</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> =&gt; <a class="idref" href="CasperCBC.VLSM.Common.html#terminating_trace_prop"><span class="id" title="definition">terminating_trace_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#tr"><span class="id" title="variable">tr</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="CasperCBC.VLSM.Common.html#Infinite"><span class="id" title="constructor">Infinite</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> =&gt; <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">End</span> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM"><span class="id" title="section">VLSM</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab12"></a><h2 class="section">VLSM Inclusion and Equality.</h2>


<div class="paragraph"> </div>

We can also define VLSM <i>inclusion</i>  and <i>equality</i> in terms of traces.
<ul class="doclist">
<li> VLSM X is <i>included</i> in VLSM Y if every <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace"><span class="id" title="definition">protocol_trace</span></a></span> available to X

</li>
</ul>
is also available to Y.
<ul class="doclist">
<li> VLSM X and VLSM Y are <i>equal</i> if their <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace"><span class="id" title="definition">protocol_trace</span></a></span>s are exactly the same.

</li>
</ul>

</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Section</span> <a name="VLSM_equality"><span class="id" title="section">VLSM_equality</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Context</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">message</span> : <span class="id" title="keyword">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">vtype</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_type"><span class="id" title="class">VLSM_type</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#message"><span class="id" title="variable">message</span></a>}.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="VLSM_eq"><span class="id" title="definition">VLSM_eq</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">SigX</span> <span class="id" title="var">SigY</span>: <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_sign"><span class="id" title="class">VLSM_sign</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_equality.vtype"><span class="id" title="variable">vtype</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">X</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM"><span class="id" title="class">VLSM</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#SigX"><span class="id" title="variable">SigX</span></a>) (<span class="id" title="var">Y</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM"><span class="id" title="class">VLSM</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#SigY"><span class="id" title="variable">SigY</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">t</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#Trace"><span class="id" title="inductive">Trace</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace_prop"><span class="id" title="definition">protocol_trace_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#X"><span class="id" title="variable">X</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#4bfb4f2d0721ba668e3a802ab1b745a1"><span class="id" title="notation">&lt;-&gt;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace_prop"><span class="id" title="definition">protocol_trace_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Y"><span class="id" title="variable">Y</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#t"><span class="id" title="variable">t</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="VLSM_incl"><span class="id" title="definition">VLSM_incl</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">SigX</span> <span class="id" title="var">SigY</span>: <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_sign"><span class="id" title="class">VLSM_sign</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_equality.vtype"><span class="id" title="variable">vtype</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">X</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM"><span class="id" title="class">VLSM</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#SigX"><span class="id" title="variable">SigX</span></a>) (<span class="id" title="var">Y</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM"><span class="id" title="class">VLSM</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#SigY"><span class="id" title="variable">SigY</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">t</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#Trace"><span class="id" title="inductive">Trace</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace_prop"><span class="id" title="definition">protocol_trace_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#X"><span class="id" title="variable">X</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#protocol_trace_prop"><span class="id" title="definition">protocol_trace_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Y"><span class="id" title="variable">Y</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#t"><span class="id" title="variable">t</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">End</span> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_equality"><span class="id" title="section">VLSM_equality</span></a>.<br/>

<br/>
</div>

<div class="doc">
It is natural to look for sufficient conditions for VLSM inclusion (or equality),
which are easy to verify in a practical setting. One such result is the following.

<div class="paragraph"> </div>

For VLSM <tt>X</tt> to be included in VLSM <tt>Y</tt>, the following set of conditions is sufficient:
<ul class="doclist">
<li> <tt>X</tt>'s <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#initial_state"><span class="id" title="method">initial_state</span></a></span>s are included in <tt>Y</tt>'s <span class="inlinecode"><span class="id" title="var">initial</span></span> <span class="inlinecode"><a class="idref" href="CasperCBC.CBC.Protocol.html#state"><span class="id" title="projection">state</span></a></span>s

</li>
<li> Every message <tt>m</tt> (including the empty one) which can be input to a
<span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_valid"><span class="id" title="definition">protocol_valid</span></a></span> transition in <tt>X</tt>, is a <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_message"><span class="id" title="definition">protocol_message</span></a></span> in <tt>Y</tt>
<div class="paragraph"> </div>


</li>
<li> <tt>X</tt>'s <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_valid"><span class="id" title="definition">protocol_valid</span></a></span> is included in <tt>Y</tt>'s <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#valid"><span class="id" title="projection">valid</span></a></span>.

</li>
<li> For all <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#protocol_valid"><span class="id" title="definition">protocol_valid</span></a></span> inputs (in <tt>X</tt>), <tt>Y</tt>'s <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#transition"><span class="id" title="projection">transition</span></a></span> acts
like <tt>X</tt>'s <span class="inlinecode"><a class="idref" href="CasperCBC.VLSM.Common.html#transition"><span class="id" title="projection">transition</span></a></span>.

</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="basic_VLSM_incl"><span class="id" title="section">basic_VLSM_incl</span></a>.<br/>

<br/>
<span class="id" title="keyword">Context</span><br/>
&nbsp;&nbsp;{<span class="id" title="var">message</span> : <span class="id" title="keyword">Type</span>}<br/>
&nbsp;&nbsp;{<span class="id" title="var">T</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_type"><span class="id" title="class">VLSM_type</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#message"><span class="id" title="variable">message</span></a>}<br/>
&nbsp;&nbsp;{<span class="id" title="var">SX</span> <span class="id" title="var">SY</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_sign"><span class="id" title="class">VLSM_sign</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#T"><span class="id" title="variable">T</span></a>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">X</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM"><span class="id" title="class">VLSM</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#SX"><span class="id" title="variable">SX</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">Y</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM"><span class="id" title="class">VLSM</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#SY"><span class="id" title="variable">SY</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">Hinitial_state</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@<a class="idref" href="CasperCBC.VLSM.Common.html#initial_state_prop"><span class="id" title="method">initial_state_prop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="CasperCBC.VLSM.Common.html#SX"><span class="id" title="variable">SX</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> @<a class="idref" href="CasperCBC.VLSM.Common.html#initial_state_prop"><span class="id" title="method">initial_state_prop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="CasperCBC.VLSM.Common.html#SY"><span class="id" title="variable">SY</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;(<span class="id" title="var">Hprotocol_message</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>) (<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>) (<span class="id" title="var">om</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#message"><span class="id" title="variable">message</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_valid"><span class="id" title="definition">protocol_valid</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#X"><span class="id" title="variable">X</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#option_protocol_message_prop"><span class="id" title="definition">option_protocol_message_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Y"><span class="id" title="variable">Y</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;(<span class="id" title="var">Hvalid</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>) (<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>) (<span class="id" title="var">om</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#message"><span class="id" title="variable">message</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_valid"><span class="id" title="definition">protocol_valid</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#X"><span class="id" title="variable">X</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> @<a class="idref" href="CasperCBC.VLSM.Common.html#valid"><span class="id" title="method">valid</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="CasperCBC.VLSM.Common.html#Y"><span class="id" title="variable">Y</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;(<span class="id" title="var">Htransition</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">l</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#label"><span class="id" title="method">label</span></a>) (<span class="id" title="var">s</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#state"><span class="id" title="method">state</span></a>) (<span class="id" title="var">om</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#message"><span class="id" title="variable">message</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#protocol_valid"><span class="id" title="definition">protocol_valid</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#X"><span class="id" title="variable">X</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">-&gt;</span></a> @<a class="idref" href="CasperCBC.VLSM.Common.html#transition"><span class="id" title="method">transition</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="CasperCBC.VLSM.Common.html#X"><span class="id" title="variable">X</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> @<a class="idref" href="CasperCBC.VLSM.Common.html#transition"><span class="id" title="method">transition</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="CasperCBC.VLSM.Common.html#Y"><span class="id" title="variable">Y</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#om"><span class="id" title="variable">om</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.2/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;.<br/>

<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="basic_VLSM_incl"><span class="id" title="lemma">basic_VLSM_incl</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_incl"><span class="id" title="definition">VLSM_incl</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#basic_VLSM_incl.X"><span class="id" title="variable">X</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#basic_VLSM_incl.Y"><span class="id" title="variable">Y</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [<span class="id" title="var">s</span> <span class="id" title="var">ls</span>| <span class="id" title="var">s</span> <span class="id" title="var">ss</span>]; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">intros</span> [<span class="id" title="var">Hxt</span> <span class="id" title="var">Hinit</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_incl_finite_ptrace"><span class="id" title="lemma">VLSM_incl_finite_ptrace</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">Hxt</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">split</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#basic_VLSM_incl.Hinitial_state"><span class="id" title="variable">Hinitial_state</span></a>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_incl_infinite_ptrace"><span class="id" title="lemma">VLSM_incl_infinite_ptrace</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">Hxt</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">split</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#basic_VLSM_incl.Hinitial_state"><span class="id" title="variable">Hinitial_state</span></a>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="CasperCBC.VLSM.Common.html#basic_VLSM_incl"><span class="id" title="section">basic_VLSM_incl</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab13"></a><h2 class="section">Pre-loaded VLSMs</h2>


<div class="paragraph"> </div>

Given a VLSM <tt>X</tt>, we introduce the <i>pre-loaded</i> version of it,
which is identical to <tt>X</tt>, except that it is endowed with the
whole message universe as its initial messages. The high degree
of freedom allowed to the <i>pre-loaded</i> version lets it experience
everything experienced by <tt>X</tt> but also other types of behaviour,
including <i>Byzantine</i> behaviour, which makes it a useful concept in
Byzantine fault tolerance analysis. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Section</span> <a name="pre_loaded_vlsm"><span class="id" title="section">pre_loaded_vlsm</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Context</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">message</span> : <span class="id" title="keyword">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">vtype</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_type"><span class="id" title="class">VLSM_type</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#message"><span class="id" title="variable">message</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">Sig</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_sign"><span class="id" title="class">VLSM_sign</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#vtype"><span class="id" title="variable">vtype</span></a>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="pre_loaded_vlsm_sig"><span class="id" title="definition">pre_loaded_vlsm_sig</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">X</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM"><span class="id" title="class">VLSM</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#pre_loaded_vlsm.Sig"><span class="id" title="variable">Sig</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_sign"><span class="id" title="class">VLSM_sign</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#pre_loaded_vlsm.vtype"><span class="id" title="variable">vtype</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{| <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">initial_state_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">@</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">initial_state_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">_</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">_</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">Sig</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">initial_message_prop</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">fun</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">message</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">=&gt;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">True</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">s0</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">@</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">s0</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">_</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">_</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">Sig</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">m0</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">@</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">m0</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">_</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">_</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">Sig</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">l0</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">@</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">l0</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">_</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">_</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM_sign"><span class="id" title="constructor">Sig</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;|}.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Context</span> (<span class="id" title="var">X</span> : <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM"><span class="id" title="class">VLSM</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#pre_loaded_vlsm.Sig"><span class="id" title="variable">Sig</span></a>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <a name="pre_loaded_vlsm"><span class="id" title="definition">pre_loaded_vlsm</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM"><span class="id" title="class">VLSM</span></a> (<a class="idref" href="CasperCBC.VLSM.Common.html#pre_loaded_vlsm_sig"><span class="id" title="definition">pre_loaded_vlsm_sig</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#pre_loaded_vlsm.X"><span class="id" title="variable">X</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{| <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM"><span class="id" title="constructor">transition</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM"><span class="id" title="constructor">@</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM"><span class="id" title="constructor">transition</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM"><span class="id" title="constructor">_</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM"><span class="id" title="constructor">_</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM"><span class="id" title="constructor">_</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM"><span class="id" title="constructor">X</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM"><span class="id" title="constructor">;</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM"><span class="id" title="constructor">valid</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM"><span class="id" title="constructor">:=</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM"><span class="id" title="constructor">@</span></a><a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM"><span class="id" title="constructor">valid</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM"><span class="id" title="constructor">_</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM"><span class="id" title="constructor">_</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM"><span class="id" title="constructor">_</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#Build_VLSM"><span class="id" title="constructor">X</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;|}.<br/>

<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <a name="vlsm_incl_pre_loaded_vlsm"><span class="id" title="lemma">vlsm_incl_pre_loaded_vlsm</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="CasperCBC.VLSM.Common.html#VLSM_incl"><span class="id" title="definition">VLSM_incl</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#pre_loaded_vlsm.X"><span class="id" title="variable">X</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#pre_loaded_vlsm"><span class="id" title="definition">pre_loaded_vlsm</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<a class="idref" href="CasperCBC.VLSM.Common.html#basic_VLSM_incl"><span class="id" title="lemma">basic_VLSM_incl</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#pre_loaded_vlsm.X"><span class="id" title="variable">X</span></a> <a class="idref" href="CasperCBC.VLSM.Common.html#pre_loaded_vlsm"><span class="id" title="definition">pre_loaded_vlsm</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">try</span> (<span class="id" title="tactic">assumption</span> || <span class="id" title="tactic">reflexivity</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;; <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">_</span> [[<span class="id" title="var">_s</span> <span class="id" title="var">Hpm</span>] <span class="id" title="var">Hv</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">exists</span> <span class="id" title="var">_s</span>. <span class="id" title="tactic">apply</span> <a class="idref" href="CasperCBC.VLSM.Common.html#pre_loaded_protocol_prop"><span class="id" title="lemma">pre_loaded_protocol_prop</span></a>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="CasperCBC.VLSM.Common.html#pre_loaded_vlsm"><span class="id" title="section">pre_loaded_vlsm</span></a>.<br/>

<br/>
</div>
</div>
<div id="footer">
  Generated by <a href="http://coq.inria.fr">coqdoc</a> and improved with <a href="https://github.com/palmskog/coqdocjs">CoqdocJS</a> as adapted for <a href="https://github.com/coq-community">coq-community</a>
</div>
</div>
</body>

</html>
