<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>Common.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><link href="alectryon.css" rel="stylesheet"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script><style type="text/css">pre { line-height: 125%; }
td.linenos pre { color: #000000; background-color: #f0f0f0; padding-left: 5px; padding-right: 5px; }
span.linenos { color: #000000; background-color: #f0f0f0; padding-left: 5px; padding-right: 5px; }
td.linenos pre.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #555753; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #cc0000 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #8f5902 } /* Keyword */
.highlight .l { color: #2e3436 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #000000 } /* Operator */
.highlight .x { color: #2e3436 } /* Other */
.highlight .p { color: #000000 } /* Punctuation */
.highlight .ch { color: #555753; font-weight: bold; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #555753; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #3465a4; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #555753; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #555753; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3465a4; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #a40000 } /* Generic.Error */
.highlight .gh { color: #a40000; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #4e9a06 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #000000; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #000000; font-style: italic } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #4e9a06; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #4e9a06; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87 } /* Keyword.Pseudo */
.highlight .kr { color: #8f5902 } /* Keyword.Reserved */
.highlight .kt { color: #204a87 } /* Keyword.Type */
.highlight .ld { color: #2e3436 } /* Literal.Date */
.highlight .m { color: #2e3436 } /* Literal.Number */
.highlight .s { color: #ad7fa8 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #75507b } /* Name.Builtin */
.highlight .nc { color: #204a87 } /* Name.Class */
.highlight .no { color: #ce5c00 } /* Name.Constant */
.highlight .nd { color: #3465a4; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #c4a000; text-decoration: underline } /* Name.Entity */
.highlight .ne { color: #cc0000 } /* Name.Exception */
.highlight .nf { color: #a40000 } /* Name.Function */
.highlight .nl { color: #3465a4; font-weight: bold } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #a40000 } /* Name.Tag */
.highlight .nv { color: #ce5c00 } /* Name.Variable */
.highlight .ow { color: #8f5902 } /* Operator.Word */
.highlight .w { color: #d3d7cf; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #2e3436 } /* Literal.Number.Bin */
.highlight .mf { color: #2e3436 } /* Literal.Number.Float */
.highlight .mh { color: #2e3436 } /* Literal.Number.Hex */
.highlight .mi { color: #2e3436 } /* Literal.Number.Integer */
.highlight .mo { color: #2e3436 } /* Literal.Number.Oct */
.highlight .sa { color: #ad7fa8 } /* Literal.String.Affix */
.highlight .sb { color: #ad7fa8 } /* Literal.String.Backtick */
.highlight .sc { color: #ad7fa8; font-weight: bold } /* Literal.String.Char */
.highlight .dl { color: #ad7fa8 } /* Literal.String.Delimiter */
.highlight .sd { color: #ad7fa8 } /* Literal.String.Doc */
.highlight .s2 { color: #ad7fa8 } /* Literal.String.Double */
.highlight .se { color: #ad7fa8; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #ad7fa8; text-decoration: underline } /* Literal.String.Heredoc */
.highlight .si { color: #ce5c00 } /* Literal.String.Interpol */
.highlight .sx { color: #ad7fa8 } /* Literal.String.Other */
.highlight .sr { color: #ad7fa8 } /* Literal.String.Regex */
.highlight .s1 { color: #ad7fa8 } /* Literal.String.Single */
.highlight .ss { color: #8f5902 } /* Literal.String.Symbol */
.highlight .bp { color: #5c35cc } /* Name.Builtin.Pseudo */
.highlight .fm { color: #a40000 } /* Name.Function.Magic */
.highlight .vc { color: #ce5c00 } /* Name.Variable.Class */
.highlight .vg { color: #ce5c00; text-decoration: underline } /* Name.Variable.Global */
.highlight .vi { color: #ce5c00 } /* Name.Variable.Instance */
.highlight .vm { color: #ce5c00 } /* Name.Variable.Magic */
.highlight .il { color: #2e3436 } /* Literal.Number.Integer.Long */</style></head><body><article class="alectryon-root alectryon-windowed alectryon-coqdoc"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.12.0+0.12.0. Coq sources are in this panel; goals and messages will appear in the other. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus.</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span>
  List Coq.Vectors.Fin
  Arith.Compare_dec Lia
  Program
  .</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Import</span> ListNotations.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> CasperCBC
  <span class="kn">Require Import</span>
    Preamble
    VLSM.Common
    .</span></span></span></pre><div class="doc">
<a id="lab1"></a><h1 class="section">Equivocator VLSMs</h1>
<div class="paragraph"> </div>

An <span class="inlinecode"><span class="id" title="var">equivocator_vlsm</span></span> for a given <span class="inlinecode"><span class="id" title="var">VLSM</span></span> <tt>X</tt> is a VLSM which
<ul class="doclist">
<li> starts as a regular machine X

</li>
<li> can equivocate any of its current copies by duplicating it.

</li>
<li> can start a new machine in a (potentially) different initial state.

</li>
<li> can perform <span class="inlinecode"><span class="id" title="var">valid</span></span> <span class="inlinecode"><span class="id" title="var">transition</span></span>s using any of the internal machines

</li>
</ul>
<div class="paragraph"> </div>

The state of such a machine will be abstracted using

<div class="paragraph"> </div>

1. A <span class="inlinecode"><span class="id" title="var">nat</span></span>ural <tt>n</tt>, stating the number of copies of the original machine
2. A state of <tt>X</tt> for each 1..n+1

<div class="paragraph"> </div>

To preserve determinism we need to update the labels to indicate what copy
of the machine will be used for a transition.
To achieve this, we'll extend the labels of <tt>X</tt>, say <tt>L_X</tt> as follows

<div class="paragraph"> </div>
<span class="inlinecode"><span class="id" title="var">L</span></span> <span class="inlinecode">=</span> <span class="inlinecode">&lt;&lt;<span class="id" title="var">L_X</span>&gt;&gt;</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">MachineDescriptor</span></span>
<div class="paragraph"> </div>

The second component of the label tells which internal machine should be
used for performing the transition. It can be one of the following:
<a id="lab2"></a><h1 class="section"><span class="inlinecode"><span class="id" title="var">NewMachine</span></span> <span class="inlinecode">&lt;&lt;<span class="id" title="var">s</span>&gt;&gt;</span> where <tt>s</tt> is an state of <tt>X</tt>, will</h1>

  extend the state with a new machine initialized with <tt>s</tt>
<div class="paragraph"> </div>

  and will perform the transition on that machine.
<a id="lab3"></a><h1 class="section"><span class="inlinecode"><span class="id" title="var">Existing</span></span> <span class="inlinecode">&lt;&lt;<span class="id" title="var">i</span>&gt;&gt;</span> <span class="inlinecode">&lt;&lt;<span class="id" title="var">is_equiv</span>&gt;&gt;</span> perform transition on internal machine <tt>i</tt></h1>

  but may equivocate, depending on the <tt>is_equiv</tt> as follows:

<div class="paragraph"> </div>
<a id="lab4"></a><h1 class="section">if <tt>is_equiv</tt> is <span class="inlinecode"><span class="id" title="var">false</span></span>, update the state of machine <tt>i</tt></h1>
<a id="lab5"></a><h1 class="section">if <tt>is_equiv</tt> is <span class="inlinecode"><span class="id" title="var">true</span></span>, duplicate the state of machine <tt>i</tt> and</h1>

    perform transition on the copy

<div class="paragraph"> </div>

These changes are reflected in the validity and transition functions.
For validity we additionaly require that the machine descriptor refers
to a valid internal machine, or to an initial state of <tt>X</tt>.

<div class="paragraph"> </div>
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">equivocator_vlsm</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span>
    {<span class="nv">message</span> : <span class="kt">Type</span>}
    (<span class="nv">X</span> : VLSM message)
    .</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">MachineDescriptor</span> : <span class="kt">Type</span>
  :=
  | NewMachine : vstate X -&gt; MachineDescriptor
  | Existing : nat -&gt; bool -&gt; MachineDescriptor.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">

</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equivocator_type</span> : VLSM_type message :=
  {| state := {n : nat &amp; Fin.t (S n) -&gt; vstate X};
     label := vlabel X * MachineDescriptor
  |}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equivocator_state</span> : <span class="kt">Type</span> := @state message equivocator_type.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">mk_singleton_state</span>
  (<span class="nv">s</span> : vstate X)
  : equivocator_state
  :=
  existT _ <span class="mi">0</span> (<span class="kr">fun</span> <span class="nv">_</span> =&gt; s).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">is_singleton_state</span>
  (<span class="nv">s</span> : equivocator_state)
  : <span class="kt">Prop</span>
  := projT1 s = <span class="mi">0</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk0"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">is_singleton_state_dec</span>
  (<span class="nv">s</span> : equivocator_state)
  : Decision (is_singleton_state s).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">equivocator_state</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Decision (is_singleton_state s)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk1"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">equivocator_state</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Decision (is_singleton_state s)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> nat_eq_dec.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">is_equivocating_state</span>
  (<span class="nv">s</span> : equivocator_state)
  : <span class="kt">Prop</span>
  := not (is_singleton_state s).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk2"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">is_equivocating_state_dec</span>
  (<span class="nv">s</span> : equivocator_state)
  : Decision (is_equivocating_state s).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">equivocator_state</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Decision (is_equivocating_state s)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk3"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">equivocator_state</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Decision (is_equivocating_state s)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk4"><span class="highlight"><span class="nb">apply</span> Decision_not.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">equivocator_state</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">Decision (is_singleton_state s)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> is_singleton_state_dec.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equivocator_label</span> : <span class="kt">Type</span> := @label message equivocator_type.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">mk_label</span>
  (<span class="nv">lx</span> : vlabel X)
  (<span class="nv">d</span> : MachineDescriptor)
  : equivocator_label
  := (lx, d).</span></span></span></pre><div class="doc">
Attempts to obtain the state of the internal machine with index <tt>i</tt>
<div class="paragraph"> </div>

from an <span class="inlinecode"><span class="id" title="var">equivocator_state</span></span>. Fails with index <tt>i</tt> does not refer to a
machine.

</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equivocator_state_project</span>
  (<span class="nv">bs</span> : equivocator_state)
  (<span class="nv">i</span> : nat)
  : option (vstate X)
  :=
  <span class="kr">let</span> (<span class="nv">n</span>, s) := bs <span class="kr">in</span>
  <span class="kr">match</span> (le_lt_dec (S n) i) <span class="kr">with</span>
  | <span class="nb">right</span> lt_in =&gt; Some (s (of_nat_lt lt_in))
  | _ =&gt;  None
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Projecting an <span class="inlinecode"><span class="id" title="var">equivocator_state</span></span> over a <span class="inlinecode"><span class="id" title="var">MachineDescriptor</span></span>.

<div class="paragraph"> </div>

This is extracted from the original <span class="inlinecode"><span class="id" title="var">equivocators_state_project</span></span> to allow
factoring out the proofs by proving properties at this level.

</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equivocator_state_descriptor_project</span>
  (<span class="nv">s</span> : equivocator_state)
  (<span class="nv">descriptor</span> : MachineDescriptor)
  : vstate X
  :=
  <span class="kr">match</span> descriptor <span class="kr">with</span>
  | NewMachine sn =&gt; sn
  | Existing j _ =&gt;
    <span class="kr">match</span> equivocator_state_project s j <span class="kr">with</span>
    | Some sj =&gt; sj
    | None =&gt; projT2 s F1
    <span class="kr">end</span> 
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equivocator_state_update</span>
  (<span class="nv">bs</span> : equivocator_state)
  (<span class="nv">n</span> := projT1 bs)
  (<span class="nv">i</span> : Fin.t (S n))
  (<span class="nv">si</span> : vstate X)
  : equivocator_state
  :=
  existT _ n
    (<span class="kr">fun</span> <span class="nv">j</span> =&gt; <span class="kr">if</span> Fin.eq_dec i j <span class="kr">then</span> si <span class="kr">else</span> projT2 bs j).</span></span></span></pre><div class="doc">
Some basic properties for 'equivocator_state_update' 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk5"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">equivocator_state_update_size</span>
  (<span class="nv">bs</span> : equivocator_state)
  (<span class="nv">i</span> : Fin.t (S (projT1 bs)))
  (<span class="nv">si</span> : vstate X)
  : projT1 (equivocator_state_update bs i si) = projT1 bs.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">equivocator_state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (S (projT1 bs))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">si</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">vstate X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projT1 (equivocator_state_update bs i si) = projT1 bs</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk6"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">equivocator_state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (S (projT1 bs))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">si</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">vstate X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projT1 (equivocator_state_update bs i si) = projT1 bs</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk7"><span class="highlight"><span class="nb">destruct</span> bs.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">v</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (S x) -&gt; vstate X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t
  (S
     (projT1
        (existT
           (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; t (S n) -&gt; vstate X) x
           v)))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">si</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">vstate X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projT1
  (equivocator_state_update
     (existT (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; t (S n) -&gt; vstate X) x v)
     i si) =
projT1
  (existT (<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt; t (S n) -&gt; vstate X) x v)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk8"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">equivocator_state_update_eq</span>
  (<span class="nv">bs</span> : equivocator_state)
  (<span class="nv">n</span> := projT1 bs)
  (<span class="nv">i</span> : Fin.t (S n))
  (<span class="nv">si</span> : vstate X)
  : projT2 (equivocator_state_update bs i si) i = si.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">equivocator_state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">projT1 bs</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (S n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">si</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">vstate X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projT2 (equivocator_state_update bs i si) i = si</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk9"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">equivocator_state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">projT1 bs</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (S n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">si</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">vstate X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projT2 (equivocator_state_update bs i si) i = si</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chka"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">equivocator_state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">projT1 bs</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (S n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">si</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">vstate X</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">if</span> eq_dec i i <span class="kr">then</span> si <span class="kr">else</span> projT2 bs i) = si</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">rewrite</span> eq_dec_if_true; <span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chkb"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">equivocator_state_update_neq</span>
  (<span class="nv">bs</span> : equivocator_state)
  (<span class="nv">n</span> := projT1 bs)
  (<span class="nv">i</span> <span class="nv">j</span> : Fin.t (S n))
  (<span class="nv">si</span> : vstate X)
  (<span class="nv">Hij</span> : i &lt;&gt; j)
  : projT2 (equivocator_state_update bs i si) j = projT2 bs j.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">equivocator_state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">projT1 bs</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i, j</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (S n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">si</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">vstate X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hij</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">i &lt;&gt; j</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projT2 (equivocator_state_update bs i si) j =
projT2 bs j</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chkc"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">equivocator_state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">projT1 bs</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i, j</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (S n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">si</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">vstate X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hij</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">i &lt;&gt; j</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projT2 (equivocator_state_update bs i si) j =
projT2 bs j</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chkd"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">equivocator_state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">projT1 bs</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i, j</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (S n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">si</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">vstate X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hij</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">i &lt;&gt; j</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">if</span> eq_dec i j <span class="kr">then</span> si <span class="kr">else</span> projT2 bs j) = projT2 bs j</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chke"><span class="highlight"><span class="nb">rewrite</span> eq_dec_if_false <span class="bp">by</span> <span class="bp">assumption</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">equivocator_state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">projT1 bs</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i, j</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (S n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">si</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">vstate X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hij</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">i &lt;&gt; j</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projT2 bs j = projT2 bs j</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Extends an <span class="inlinecode"><span class="id" title="var">equivocator_state</span></span> with a new state of the original machine.

</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equivocator_state_extend</span>
  (<span class="nv">bs</span> : equivocator_state)
  (<span class="nv">s</span> : vstate X)
  : equivocator_state
  :=
  <span class="kr">let</span> (<span class="nv">n</span>, <span class="kr">is</span>) := bs <span class="kr">in</span>
  existT _ (S n)
    (<span class="kr">fun</span> <span class="nv">j</span> =&gt;
      <span class="kr">let</span> (<span class="nv">nj</span>, Hnj) := to_nat j <span class="kr">in</span>
      <span class="kr">if</span> (nat_eq_dec nj (S n)) <span class="kr">then</span> s <span class="kr">else</span> <span class="kr">is</span> (@of_nat_lt nj (S n) _)
    ).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chkf"><span class="highlight"><span class="kn">Next Obligation</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">equivocator_state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">vstate X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">is</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (S n) -&gt; vstate X</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">j</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">t (S (S n))</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">nj</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hnj</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nj &lt; S (S n)</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">H</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nj &lt;&gt; S n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">nj &lt; S n</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">lia</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span></span></pre><div class="doc">
The original state index is present in any equivocator state
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk10"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">Hzero</span> (<span class="nv">s</span> : equivocator_state) : <span class="mi">0</span> &lt; S (projT1 s).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">equivocator_state</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> &lt; S (projT1 s)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk11"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">equivocator_state</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> &lt; S (projT1 s)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">lia</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="c">(* An [equivocator_state] has the [initial_state_prop]erty if it only</span>
<span class="c">contains one state of original machine, and that state is initial.</span>
<span class="c">*)</span>
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equivocator_initial_state_prop</span>
  (<span class="nv">bs</span> : equivocator_state)
  : <span class="kt">Prop</span>
  := projT1 bs = <span class="mi">0</span> /\ vinitial_state_prop X (projT2 bs (of_nat_lt (Hzero bs))).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equivocator_initial_state</span>
  := sig equivocator_initial_state_prop.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk12"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equivocator_s0</span> : equivocator_initial_state.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">equivocator_initial_state</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk13"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">equivocator_initial_state</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk14"><span class="highlight"><span class="kr">exists</span> (<span class="nv">mk_singleton_state</span> (proj1_sig (vs0 X))).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">equivocator_initial_state_prop
  (mk_singleton_state (` (vs0 X)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk15"><span class="highlight"><span class="nb">unfold</span> mk_singleton_state.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">equivocator_initial_state_prop
  (existT (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; t (S x) -&gt; vstate X) <span class="mi">0</span>
     (<span class="kr">fun</span> <span class="nv">_</span> : t <span class="mi">1</span> =&gt; ` (vs0 X)))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk16"><span class="highlight"><span class="nb">unfold</span> equivocator_initial_state_prop.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">projT1
  (existT (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; t (S x) -&gt; vstate X) <span class="mi">0</span>
     (<span class="kr">fun</span> <span class="nv">_</span> : t <span class="mi">1</span> =&gt; ` (vs0 X))) = <span class="mi">0</span> /\
vinitial_state_prop X
  (projT2
     (existT (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; t (S x) -&gt; vstate X) <span class="mi">0</span>
        (<span class="kr">fun</span> <span class="nv">_</span> : t <span class="mi">1</span> =&gt; ` (vs0 X)))
     (of_nat_lt
        (Hzero
           (existT
              (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; t (S x) -&gt; vstate X) <span class="mi">0</span>
              (<span class="kr">fun</span> <span class="nv">_</span> : t <span class="mi">1</span> =&gt; ` (vs0 X))))))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk17"><span class="highlight"><span class="nb">split</span>; [<span class="bp">reflexivity</span>|].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">vinitial_state_prop X
  (projT2
     (existT (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; t (S x) -&gt; vstate X) <span class="mi">0</span>
        (<span class="kr">fun</span> <span class="nv">_</span> : t <span class="mi">1</span> =&gt; ` (vs0 X)))
     (of_nat_lt
        (Hzero
           (existT
              (<span class="kr">fun</span> <span class="nv">x</span> : nat =&gt; t (S x) -&gt; vstate X) <span class="mi">0</span>
              (<span class="kr">fun</span> <span class="nv">_</span> : t <span class="mi">1</span> =&gt; ` (vs0 X))))))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk18"><span class="highlight"><span class="nb">simpl</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">vinitial_state_prop X (` (vs0 X))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk19"><span class="highlight"><span class="nb">destruct</span> (vs0 X).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">state</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">i</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">initial_state_prop x</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">vinitial_state_prop X
  (`
   (exist (<span class="kr">fun</span> <span class="nv">s</span> : state =&gt; initial_state_prop s) x i))</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Defined</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equivocator_l0</span> : equivocator_label :=
  (vl0 X, Existing <span class="mi">0</span> false).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equivocator_sig</span>
  : VLSM_sign equivocator_type
  :=
    {|   initial_state_prop := equivocator_initial_state_prop
       ; s0 := equivocator_s0
       ; initial_message_prop := vinitial_message_prop X
       ; m0 := vm0 X
       ; l0 := equivocator_l0
    |}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equivocator_transition</span>
  (<span class="nv">bl</span> : equivocator_label)
  (<span class="nv">bsom</span> : equivocator_state * option message)
  : equivocator_state * option message
  :=
  <span class="kr">let</span> (<span class="nv">bs</span>, om) := bsom <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">n</span> := projT1 bs <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">s</span> := projT2 bs <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">l</span> := fst bl <span class="kr">in</span>
  <span class="kr">match</span> snd bl <span class="kr">with</span>
  | NewMachine sn  =&gt; <span class="c">(* creating a new machine with initial state sn*)</span>
    (equivocator_state_extend bs sn, None)
  | Existing i is_equiv =&gt; <span class="c">(* transition using the state of machine i *)</span>
    <span class="kr">match</span> (le_lt_dec (S n) i) <span class="kr">with</span>
    | <span class="nb">right</span> lt_in =&gt;
      <span class="kr">let</span> <span class="nv">ni</span> := of_nat_lt lt_in <span class="kr">in</span>
      <span class="kr">let</span> <span class="nv">si</span> := s ni <span class="kr">in</span>
      <span class="kr">let</span> (<span class="nv">si&#39;</span>, om&#39;) := vtransition X l (si, om) <span class="kr">in</span>
      <span class="kr">match</span> is_equiv <span class="kr">with</span>
      | false =&gt; (equivocator_state_update bs ni si&#39;, om&#39;) <span class="c">(* not equivocating *)</span>
      | true =&gt; (equivocator_state_extend bs si&#39;, om&#39;) <span class="c">(* equivocating in a new copy *)</span>
      <span class="kr">end</span>
    | _ =&gt;  bsom
    <span class="kr">end</span>
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equivocator_valid</span>
  (<span class="nv">bl</span> : equivocator_label)
  (<span class="nv">bsom</span> : equivocator_state * option message)
  : <span class="kt">Prop</span>
  :=
  <span class="kr">let</span> (<span class="nv">bs</span>, om) := bsom <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">n</span> := projT1 bs <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">s</span> := projT2 bs <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">l</span> := fst bl <span class="kr">in</span>
  <span class="kr">match</span> snd bl <span class="kr">with</span>
  | NewMachine sn  =&gt; <span class="c">(* state is initial *)</span>
    vinitial_state_prop X sn /\ om = None
  | Existing i is_equiv =&gt; <span class="c">(* the index is good, and transition valid for it *)</span>
    <span class="kr">exists</span> (<span class="nv">Hi</span> : i &lt; S n), vvalid X l (s (of_nat_lt Hi), om)
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equivocator_vlsm_machine</span>
  : VLSM_class equivocator_sig
  :=
  {|  transition := equivocator_transition
   ;  valid := equivocator_valid
  |}.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">equivocator_vlsm</span>
  : VLSM message
  :=
  mk_vlsm equivocator_vlsm_machine.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">equivocator_vlsm</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">equivocator_vlsm_protocol_state_projections</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span>
  {<span class="nv">message</span> : <span class="kt">Type</span>}
  (<span class="nv">X</span> : VLSM message)
  (<span class="nv">equivocator_vlsm</span> := equivocator_vlsm X)
  (<span class="nv">MachineDescriptor</span> := MachineDescriptor X)
  .</span></span></span></pre><div class="doc">
Whether a <span class="inlinecode"><span class="id" title="var">MachineDescriptor</span></span> can be used to project an
 <span class="inlinecode"><span class="id" title="var">equivocator_state</span></span> to a regular <span class="inlinecode"><span class="id" title="var">state</span></span>.
 The <span class="inlinecode"><span class="id" title="var">NewMachine</span></span> descriptor signals that an equivocation has occured
 starting a new machine, thus we require the argument to be initial.
 For an <span class="inlinecode"><span class="id" title="var">Existing</span></span> descriptor, the index of the descriptor must
 refer to an existing machine in the current state.
 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">proper_descriptor</span>
  (<span class="nv">d</span> : MachineDescriptor)
  (<span class="nv">s</span> : vstate equivocator_vlsm)
  :=
  <span class="kr">match</span> d <span class="kr">with</span>
  | NewMachine _ sn =&gt; vinitial_state_prop X sn
  | Existing _ i _ =&gt; i &lt; S (projT1 s)
  <span class="kr">end</span>.</span></span></span></pre><div class="doc">
Same as above, but disallowing equivocation. 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">not_equivocating_descriptor</span>
  (<span class="nv">d</span> : MachineDescriptor)
  (<span class="nv">s</span> : vstate equivocator_vlsm)
  :=
  <span class="kr">match</span> d <span class="kr">with</span>
  | Existing _ i false =&gt; i &lt; S (projT1 s)
  | _ =&gt; <span class="kt">False</span>
  <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk1a"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">not_equivocating_descriptor_proper</span>
  (<span class="nv">d</span> : MachineDescriptor)
  (<span class="nv">s</span> : vstate equivocator_vlsm)
  (<span class="nv">Hned</span> : not_equivocating_descriptor d s)
  : proper_descriptor d s.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">equivocator_vlsm</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">SerTop.equivocator_vlsm X</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">MachineDescriptor</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">SerTop.MachineDescriptor X</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MachineDescriptor</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">vstate equivocator_vlsm</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hned</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">not_equivocating_descriptor d s</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">proper_descriptor d s</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk1b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">equivocator_vlsm</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">SerTop.equivocator_vlsm X</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">MachineDescriptor</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">SerTop.MachineDescriptor X</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">d</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">MachineDescriptor</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">vstate equivocator_vlsm</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hned</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">not_equivocating_descriptor d s</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">proper_descriptor d s</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk1c"><span class="highlight"><span class="nb">destruct</span> d; [<span class="bp">contradict</span> Hned|].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">equivocator_vlsm</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">SerTop.equivocator_vlsm X</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">MachineDescriptor</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">SerTop.MachineDescriptor X</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">vstate equivocator_vlsm</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hned</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">not_equivocating_descriptor (Existing X n b) s</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">proper_descriptor (Existing X n b) s</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk1d"><span class="highlight"><span class="nb">destruct</span> b; [<span class="bp">contradict</span> Hned|].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">message</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">X</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">equivocator_vlsm</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">SerTop.equivocator_vlsm X</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">VLSM message</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">MachineDescriptor</span><span><span class="hyp-body-block"><span class="hyp-punct">:=</span><span class="hyp-body"><span class="highlight">SerTop.MachineDescriptor X</span></span></span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">vstate equivocator_vlsm</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hned</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">not_equivocating_descriptor
  (Existing X n false) s</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">proper_descriptor (Existing X n false) s</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="Common-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="Common-v-chk1e"><span class="highlight"><span class="kn">Ltac</span> <span class="nf">unfold_transition</span> H :=
  ( <span class="nb">unfold</span> transition <span class="kr">in</span> H; <span class="nb">unfold</span> equivocator_vlsm <span class="kr">in</span> H
  ; <span class="nb">unfold</span> Common.equivocator_vlsm <span class="kr">in</span> H
  ; <span class="nb">unfold</span> mk_vlsm <span class="kr">in</span> H; <span class="nb">unfold</span> machine <span class="kr">in</span> H
  ; <span class="nb">unfold</span> projT2 <span class="kr">in</span> H; <span class="nb">unfold</span> equivocator_vlsm_machine <span class="kr">in</span> H
  ; <span class="nb">unfold</span> equivocator_transition <span class="kr">in</span> H).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">The reference Common.equivocator_vlsm was not found
<span class="kr">in</span> the current environment.</span></blockquote></div></div></small></span></pre><div class="doc">
Protocol messages in the <span class="inlinecode"><span class="id" title="var">equivocator_vlsm</span></span> are also protocol in the
original machine.  All components of a protocol state in the
<span class="inlinecode"><span class="id" title="var">equivocator_vlsm</span></span> are also protocol in the original machine.

</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">equivocator_state_project_protocol</span>
  (<span class="nv">bs</span> : vstate equivocator_vlsm)
  (<span class="nv">om</span> : option message)
  (<span class="nv">Hbs</span> : protocol_prop equivocator_vlsm (bs, om))
  :
  option_protocol_message_prop X om /\
  <span class="kr">let</span> (<span class="nv">n</span>, bs) := bs <span class="kr">in</span>
  <span class="kr">forall</span> (<span class="nv">i</span> : Fin.t (S n)), protocol_state_prop X (bs i).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Proof</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">dependent induction</span> Hbs; <span class="nb">split</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">-</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kr">exists</span> (<span class="nv">proj1_sig</span> (vs0 X)).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> protocol_initial_state.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">-</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> <span class="kr">is</span> <span class="kr">as</span> [<span class="kr">is</span> His].</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> s; <span class="nb">clear</span> s.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">simpl</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> His <span class="kr">as</span> [Hzero His].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> <span class="kr">is</span> <span class="kr">as</span> (n, <span class="kr">is</span>).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> Hzero.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">subst</span> n.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> His.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intro</span> i.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">dependent destruction</span> i; [|<span class="nb">inversion</span> i].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kr">exists</span> <span class="nv">None</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">change</span> (<span class="kr">is</span> F1) <span class="kr">with</span> (proj1_sig (exist _ _ His)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> protocol_initial_state.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">-</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> om0; <span class="nb">clear</span> om0.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kr">exists</span> (<span class="nv">proj1_sig</span> (vs0 X)).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> (protocol_initial_message X).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">-</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> s; <span class="nb">clear</span> s.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> s0.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">simpl</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intro</span> i.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kr">exists</span> <span class="nv">None</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> protocol_initial_state.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">-</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">specialize</span> (IHHbs1 X s _om eq_refl JMeq_refl).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">specialize</span> (IHHbs2 X _s om0 eq_refl JMeq_refl).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">specialize</span> (protocol_generated X) <span class="kr">as</span> Hgen.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> Hv.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> l <span class="kr">as</span> (l, descriptor).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> Hv.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> descriptor <span class="kr">as</span> [sn| i is_equiv].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">+</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> Hv <span class="kr">as</span> [Hsn Hv].</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">subst</span> om0.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> x.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">inversion</span> x.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">subst</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> IHHbs2.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">+</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">unfold_transition x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> snd <span class="kr">in</span> x.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> Hv <span class="kr">as</span> [Hi Hv].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (le_lt_dec (S (projT1 s)) i); [<span class="bp">lia</span>|].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">replace</span> (of_nat_lt l0) <span class="kr">with</span> (of_nat_lt Hi) <span class="kr">in</span> * <span class="bp">by</span> <span class="nb">apply</span> of_nat_ext.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">clear</span> l0.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> s <span class="kr">as</span> (n, bs&#39;).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> IHHbs1 <span class="kr">as</span> [_ IHHbs1].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">spec IHHbs1 (of_nat_lt Hi).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> IHHbs1 <span class="kr">as</span> [_om&#39; Hbs&#39;t].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> IHHbs2 <span class="kr">as</span> [Hom _].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">clear</span> Hbs2 _s.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> Hom <span class="kr">as</span> [_s Hom].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">specialize</span> (Hgen l (bs&#39; (of_nat_lt Hi)) _om&#39; Hbs&#39;t _s om0 Hom Hv).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kr">match</span> <span class="kp">type of</span> Hgen <span class="kr">with</span>
      | protocol_prop _ <span class="nl">?t</span> =&gt;
        <span class="nb">change</span> t  <span class="kr">with</span> (vtransition X l (bs&#39; (of_nat_lt Hi), om0))
          <span class="kr">in</span> Hgen
      <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> *.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (vtransition X l (bs&#39; (of_nat_lt Hi), om0)) <span class="kr">as</span> (si&#39;, om&#39;) <span class="nb">eqn</span>:Ht.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kr">exists</span> <span class="nv">si&#39;</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> is_equiv <span class="kr">as</span> [|]; <span class="nb">inversion</span> x; <span class="nb">subst</span>; <span class="bp">assumption</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">-</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> bs <span class="kr">as</span> (n, bs).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intro</span> j.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">specialize</span> (IHHbs1 X s _om eq_refl JMeq_refl).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> IHHbs1 <span class="kr">as</span> [_ IHHbs1].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">specialize</span> (IHHbs2 X _s om0 eq_refl JMeq_refl).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">specialize</span> (protocol_generated X) <span class="kr">as</span> Hgen.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">unfold_transition x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> l <span class="kr">as</span> (l, descriptor).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> snd <span class="kr">in</span> x.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> descriptor <span class="kr">as</span> [sn | i is_equiv].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">+</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> Hv <span class="kr">as</span> [Hsn Hv].</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">subst</span> om0.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">inversion</span> x.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">subst</span> om.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> equivocator_state_extend <span class="kr">in</span> H0.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> s <span class="kr">as</span> (n0, bs0).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">inversion</span> H0.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">subst</span> n.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">simpl_existT.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">subst</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (to_nat j) <span class="kr">as</span> (nj, Hnj).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kp">try</span> <span class="nb">destruct</span> (nat_eq_dec nj (S n0)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">*</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kr">exists</span> <span class="nv">None</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">change</span> sn <span class="kr">with</span> (proj1_sig (exist _ sn Hsn)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">constructor</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">*</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> IHHbs1.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">+</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> Hv <span class="kr">as</span> [Hi Hv].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (le_lt_dec (S (projT1 s)) i); [<span class="bp">lia</span>|].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">replace</span> (of_nat_lt l0) <span class="kr">with</span> (of_nat_lt Hi) <span class="kr">in</span> * <span class="bp">by</span> <span class="nb">apply</span> of_nat_ext.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">clear</span> l0.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> s <span class="kr">as</span> (n0, bs0); <span class="nb">simpl</span> <span class="kr">in</span> *.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (IHHbs1 (of_nat_lt Hi)) <span class="kr">as</span> [_om0 Hbs0t].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> IHHbs2 <span class="kr">as</span> [(_som, Hom) _].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">specialize</span> (Hgen l (bs0 (of_nat_lt Hi))  _om0 Hbs0t _som om0 Hom Hv).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kr">match</span> <span class="kp">type of</span> Hgen <span class="kr">with</span>
      | protocol_prop _ <span class="nl">?t</span> =&gt;
        <span class="nb">change</span> t  <span class="kr">with</span> (vtransition X l (bs0 (of_nat_lt Hi), om0))
          <span class="kr">in</span> Hgen
      <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (vtransition X l (bs0 (of_nat_lt Hi), om0)) <span class="kr">as</span> (si&#39;, om&#39;) <span class="nb">eqn</span>:Ht.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> is_equiv <span class="kr">as</span> [|]; <span class="nb">inversion</span> x; <span class="nb">clear</span> x
      ; <span class="nb">subst</span> n om&#39;; <span class="nb">apply</span> inj_pairT2 <span class="kr">in</span> H1; <span class="nb">subst</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">*</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (to_nat j) <span class="kr">as</span> (nj, Hnj).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (nat_eq_dec  nj (S n0)); [<span class="kr">exists</span> <span class="nv">om</span>; <span class="bp">assumption</span>|].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> IHHbs1.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">*</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (Fin.eq_dec (of_nat_lt Hi) j); [|<span class="nb">apply</span> IHHbs1].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kr">exists</span> <span class="nv">om</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">equivocator_state_project_protocol_state</span>
  (<span class="nv">bs</span> : vstate equivocator_vlsm)
  (<span class="nv">Hbs</span> : protocol_state_prop equivocator_vlsm bs)
  :
  <span class="kr">let</span> (<span class="nv">n</span>, bs) := bs <span class="kr">in</span>
  <span class="kr">forall</span> (<span class="nv">i</span> : Fin.t (S n)), protocol_state_prop X (bs i).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Proof</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> Hbs <span class="kr">as</span> [om Hbs].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> equivocator_state_project_protocol <span class="kr">in</span> Hbs.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> proj2 <span class="kr">in</span> Hbs.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">equivocator_state_project_protocol_message</span>
  (<span class="nv">om</span> : option message)
  (<span class="nv">Hom</span> : option_protocol_message_prop equivocator_vlsm om)
  :
  option_protocol_message_prop X om.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Proof</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> Hom <span class="kr">as</span> [s Hom].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> equivocator_state_project_protocol <span class="kr">in</span> Hom.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> proj1 <span class="kr">in</span> Hom.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
All components of a protocol states of the <span class="inlinecode"><span class="id" title="var">pre_loaded_with_all_messages_vlsm</span></span> corresponding
to an <span class="inlinecode"><span class="id" title="var">equivocator_vlsm</span></span> are also protocol for the <span class="inlinecode"><span class="id" title="var">pre_loaded_with_all_messages_vlsm</span></span>
corresponding to the original machine.

</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">preloaded_equivocator_state_project_protocol_state</span>
  (<span class="nv">bs</span> : vstate equivocator_vlsm)
  (<span class="nv">Hbs</span> : protocol_state_prop (pre_loaded_with_all_messages_vlsm equivocator_vlsm) bs)
  (<span class="nv">i</span> : Fin.t (S (projT1 bs)))
  :
  protocol_state_prop (pre_loaded_with_all_messages_vlsm X) (projT2 bs i).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Proof</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">revert</span> bs Hbs i.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">induction</span> <span class="mi">1</span> <span class="nb">using</span> protocol_state_prop_ind;<span class="nb">intros</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">-</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> Hs <span class="kr">as</span> [Hzero His].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> s.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> *.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">subst</span> x.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kr">exists</span> <span class="nv">None</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">dependent destruction</span> i; [|<span class="nb">inversion</span> i].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">change</span> (v F1) <span class="kr">with</span> (proj1_sig (exist _ _ His)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> (protocol_initial_state (pre_loaded_with_all_messages_vlsm X)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">-</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> Ht <span class="kr">as</span> [[Hps [_ Hv]] Ht].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> Ht.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> vtransition <span class="kr">in</span> Ht.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">unfold_transition Ht.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> l <span class="kr">as</span> (l, description).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> snd <span class="kr">in</span> Ht.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> description <span class="kr">as</span> [sn| j is_equiv].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">+</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> Hv <span class="kr">as</span> [Hsn Hv].</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">subst</span> om.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">inversion</span> Ht.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">subst</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> equivocator_state_extend.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> s <span class="kr">as</span> (ns, bs).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> *.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (to_nat i) <span class="kr">as</span> (ni, Hni).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (nat_eq_dec ni (S ns)); [|<span class="nb">apply</span> IHHbs].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">subst</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kr">exists</span> <span class="nv">None</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">change</span> sn <span class="kr">with</span> (proj1_sig (exist _ sn Hsn)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">constructor</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">+</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> Hv <span class="kr">as</span> [Hj Hv].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (le_lt_dec (S (projT1 s)) j); [<span class="bp">lia</span>|].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">replace</span> (of_nat_lt l0) <span class="kr">with</span> (of_nat_lt Hj) <span class="kr">in</span> * <span class="bp">by</span> <span class="nb">apply</span> of_nat_ext.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">clear</span> l0.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (IHHbs (of_nat_lt Hj)) <span class="kr">as</span> [_omj Hsj].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">specialize</span> (protocol_generated (pre_loaded_with_all_messages_vlsm X) l (projT2 s (of_nat_lt Hj)) _omj Hsj)
        <span class="kr">as</span> Hgen.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">spec Hgen (proj1_sig (vs0 X)) om (pre_loaded_with_all_messages_message_protocol_prop X om) Hv.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">change</span> (transition l (projT2 s (of_nat_lt Hj), om))
        <span class="kr">with</span> (vtransition X l (projT2 s (of_nat_lt Hj), om))
        <span class="kr">in</span> Hgen.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> *.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (vtransition X l (projT2 s (of_nat_lt Hj), om)) <span class="kr">as</span> (sj&#39;, omj&#39;).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> is_equiv <span class="kr">as</span> [|]; <span class="nb">inversion</span> Ht; <span class="nb">subst</span>; <span class="nb">clear</span> Ht; <span class="nb">simpl</span> <span class="kr">in</span> *.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">*</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> s <span class="kr">as</span> (ns, bs).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> *.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (to_nat i) <span class="kr">as</span> (ni, Hni).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (nat_eq_dec ni (S ns)); [|<span class="nb">apply</span> IHHbs].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kr">exists</span> <span class="nv">om&#39;</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">*</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (Fin.eq_dec (of_nat_lt Hj) i); [|<span class="nb">apply</span> IHHbs].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kr">exists</span> <span class="nv">om&#39;</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">assumption</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><div class="doc">
Next couple of lemmas characterize the projections of a <span class="inlinecode"><span class="id" title="var">equivocator_state</span></span>
after taking a transition in terms of the preceeeding state.

<div class="paragraph"> </div>

These are simpler version of the results concerning the projection of
states from the composition of equivocators over <span class="inlinecode"><span class="id" title="var">equivocation_choice</span></span>s.

<div class="paragraph"> </div>

These results are used for characterizing the projection of the <span class="inlinecode"><span class="id" title="var">destination</span></span>
of a <span class="inlinecode"><span class="id" title="var">transition_item</span></span> in an equivocator trace in
<span class="inlinecode"><span class="id" title="var">equivocator_transition_item_project_proper_characterization</span></span>.

</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">new_machine_label_equivocator_state_project_last</span>
  (<span class="nv">l</span> : vlabel equivocator_vlsm) <span class="nv">s</span> <span class="nv">oin</span> <span class="nv">s&#39;</span> <span class="nv">oout</span>
  (<span class="nv">Ht</span> : vtransition equivocator_vlsm l (s, oin) = (s&#39;, oout))
  <span class="nv">sn</span>
  (<span class="nv">Hnew</span>: snd l = NewMachine _ sn)
  <span class="nv">fi</span>
  : equivocator_state_descriptor_project X s&#39; (Existing _ (projT1 s&#39;) fi) =
    equivocator_state_descriptor_project X s (NewMachine _ sn).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Proof</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> l <span class="kr">as</span> (l, new).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> Hnew.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">subst</span> new.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> vtransition <span class="kr">in</span> Ht.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> Ht.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">inversion</span> Ht.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">subst</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">clear</span> Ht.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">remember</span> (equivocator_state_extend X s sn) <span class="kr">as</span> ext.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> ext <span class="kr">as</span> (n, bs).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> projT1.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> equivocator_state_descriptor_project.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> equivocator_state_project.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (le_lt_dec (S n) n); [<span class="bp">lia</span>|].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> s <span class="kr">as</span> (nsi, bsi).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> equivocator_state_extend <span class="kr">in</span> Heqext.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">inversion</span> Heqext.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">subst</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">simpl_existT.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">subst</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">rewrite</span> to_nat_of_nat.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (nat_eq_dec (S nsi) (S nsi)); [|<span class="bp">congruence</span>].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">new_machine_label_equivocator_state_project_not_last</span>
  (<span class="nv">l</span> : vlabel equivocator_vlsm) <span class="nv">s</span> <span class="nv">oin</span> <span class="nv">s&#39;</span> <span class="nv">oout</span>
  (<span class="nv">Ht</span> : vtransition equivocator_vlsm l (s, oin) = (s&#39;, oout))
  <span class="nv">sn</span>
  (<span class="nv">Hnew</span>: snd l = NewMachine _ sn)
  <span class="nv">ni</span> <span class="nv">fi</span>
  (<span class="nv">Hni</span> : ni &lt; projT1 s&#39;)
  <span class="nv">fi&#39;</span>
  : equivocator_state_descriptor_project X s&#39; (Existing _ ni fi) =
    equivocator_state_descriptor_project X s (Existing _ ni fi&#39;).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Proof</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> l <span class="kr">as</span> (li, new).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> Hnew.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">subst</span> new.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">inversion</span> Ht.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">subst</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> equivocator_state_descriptor_project.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> equivocator_state_project.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> equivocator_state_extend.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> equivocator_state_extend <span class="kr">in</span> Hni.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> s <span class="kr">as</span> (nsi&#39;, bsi&#39;).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> projT1 <span class="kr">in</span> Hni.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (le_lt_dec (S (S nsi&#39;)) ni); [<span class="bp">lia</span>|].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">rewrite</span> to_nat_of_nat.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (nat_eq_dec ni (S nsi&#39;)); [<span class="bp">lia</span>|].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (le_lt_dec (S nsi&#39;) ni); [<span class="bp">lia</span>|].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">f_equal</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> of_nat_ext.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">existing_true_label_equivocator_state_project_not_last</span>
  (<span class="nv">l</span> : vlabel equivocator_vlsm) <span class="nv">s</span> <span class="nv">oin</span> <span class="nv">s&#39;</span> <span class="nv">oout</span>
  (<span class="nv">Ht</span> : vtransition equivocator_vlsm l (s, oin) = (s&#39;, oout))
  <span class="nv">ieqvi</span>
  (<span class="nv">Hex_true</span>: snd l = Existing _ ieqvi true)
  (<span class="nv">Hieqvi</span> : ieqvi &lt; S (projT1 s))
  <span class="nv">ni</span> <span class="nv">fi</span>
  (<span class="nv">Hni</span> : ni &lt; projT1 s&#39;)
  <span class="nv">fi&#39;</span>
  : equivocator_state_descriptor_project X s&#39; (Existing _ ni fi)
  = equivocator_state_descriptor_project X s (Existing _ ni fi&#39;).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Proof</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> l <span class="kr">as</span> (li, ex_true).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> Hex_true.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">subst</span> ex_true.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> vtransition <span class="kr">in</span> Ht.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">unfold_transition Ht.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> snd <span class="kr">in</span> Ht.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> ( le_lt_dec (S (projT1 s)) ieqvi ); [<span class="bp">lia</span>|].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span>
    (vtransition X (fst (li, Existing X ieqvi true))
    (projT2 s (of_nat_lt l), oin))
    <span class="kr">as</span> (si&#39;&#39;, om&#39;&#39;).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">inversion</span> Ht.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">subst</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">clear</span> Ht.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> equivocator_state_descriptor_project.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> equivocator_state_project.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> equivocator_state_extend.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> equivocator_state_extend <span class="kr">in</span> Hni.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> s <span class="kr">as</span> (nsi&#39;, bsi&#39;).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> projT1 <span class="kr">in</span> Hni.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (le_lt_dec (S (S nsi&#39;)) ni); [<span class="bp">lia</span>|].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">rewrite</span> to_nat_of_nat.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (nat_eq_dec ni (S nsi&#39;)); [<span class="bp">lia</span>|].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (le_lt_dec (S nsi&#39;) ni); [<span class="bp">lia</span>|].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">f_equal</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> of_nat_ext.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">existing_false_label_equivocator_state_project_not_same</span>
  (<span class="nv">l</span> : vlabel equivocator_vlsm) <span class="nv">s</span> <span class="nv">oin</span> <span class="nv">s&#39;</span> <span class="nv">oout</span>
  (<span class="nv">Ht</span> : vtransition equivocator_vlsm l (s, oin) = (s&#39;, oout))
  <span class="nv">ieqvi</span>
  (<span class="nv">Hex_false</span>: snd l = Existing _ ieqvi false)
  (<span class="nv">Hieqvi</span> : ieqvi &lt; S (projT1 s))
  <span class="nv">ni</span> <span class="nv">fi</span>
  (<span class="nv">Hni</span> : ni &lt; S (projT1 s&#39;))
  (<span class="nv">Hnieqvi</span> : ieqvi &lt;&gt; ni)
  <span class="nv">fi&#39;</span>
  : equivocator_state_descriptor_project X s&#39; (Existing _ ni fi)
  = equivocator_state_descriptor_project X s (Existing _ ni fi&#39;).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Proof</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> l <span class="kr">as</span> (li, ex_false).</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> Hex_false.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">subst</span> ex_false.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> vtransition <span class="kr">in</span> Ht.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight">unfold_transition Ht.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> snd <span class="kr">in</span> Ht.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> ( le_lt_dec (S (projT1 s)) ieqvi ); [<span class="bp">lia</span>|].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span>
    (vtransition X (fst (li, Existing X ieqvi false))
    (projT2 s (of_nat_lt l), oin))
    <span class="kr">as</span> (si&#39;&#39;, om&#39;&#39;).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">inversion</span> Ht.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">subst</span>.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">clear</span> Ht.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> equivocator_state_descriptor_project.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> equivocator_state_project.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> s <span class="kr">as</span> (nsi&#39;, bsi&#39;).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">simpl</span> <span class="kr">in</span> Hieqvi, l.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> equivocator_state_update <span class="kr">in</span> *.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">unfold</span> projT1 <span class="kr">in</span> *.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">destruct</span> (le_lt_dec (S nsi&#39;) ni); [<span class="bp">lia</span>|].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">rewrite</span> eq_dec_if_false; [<span class="bp">reflexivity</span>|].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">intro</span> contra.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">elim</span> Hnieqvi.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">apply</span> (<span class="nb">f_equal</span> to_nat) <span class="kr">in</span> contra.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kp">repeat</span> <span class="nb">rewrite</span> to_nat_of_nat <span class="kr">in</span> contra.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="nb">inversion</span> contra.</span></span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">reflexivity</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
<span class="kn">End</span> <span class="nf">equivocator_vlsm_protocol_state_projections</span>.</span></span></pre></article></body></html>