<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>Liveness.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><link href="alectryon.css" rel="stylesheet"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script><style type="text/css">pre { line-height: 125%; }
td.linenos pre { color: #000000; background-color: #f0f0f0; padding-left: 5px; padding-right: 5px; }
span.linenos { color: #000000; background-color: #f0f0f0; padding-left: 5px; padding-right: 5px; }
td.linenos pre.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #555753; font-style: italic } /* Comment */
.highlight .err { color: #a40000; border: 1px solid #cc0000 } /* Error */
.highlight .g { color: #000000 } /* Generic */
.highlight .k { color: #8f5902 } /* Keyword */
.highlight .l { color: #2e3436 } /* Literal */
.highlight .n { color: #000000 } /* Name */
.highlight .o { color: #000000 } /* Operator */
.highlight .x { color: #2e3436 } /* Other */
.highlight .p { color: #000000 } /* Punctuation */
.highlight .ch { color: #555753; font-weight: bold; font-style: italic } /* Comment.Hashbang */
.highlight .cm { color: #555753; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #3465a4; font-style: italic } /* Comment.Preproc */
.highlight .cpf { color: #555753; font-style: italic } /* Comment.PreprocFile */
.highlight .c1 { color: #555753; font-style: italic } /* Comment.Single */
.highlight .cs { color: #3465a4; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #a40000 } /* Generic.Deleted */
.highlight .ge { color: #000000; font-style: italic } /* Generic.Emph */
.highlight .gr { color: #a40000 } /* Generic.Error */
.highlight .gh { color: #a40000; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #4e9a06 } /* Generic.Inserted */
.highlight .go { color: #000000; font-style: italic } /* Generic.Output */
.highlight .gp { color: #8f5902 } /* Generic.Prompt */
.highlight .gs { color: #000000; font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #000000; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #000000; font-style: italic } /* Generic.Traceback */
.highlight .kc { color: #204a87; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #4e9a06; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #4e9a06; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #204a87 } /* Keyword.Pseudo */
.highlight .kr { color: #8f5902 } /* Keyword.Reserved */
.highlight .kt { color: #204a87 } /* Keyword.Type */
.highlight .ld { color: #2e3436 } /* Literal.Date */
.highlight .m { color: #2e3436 } /* Literal.Number */
.highlight .s { color: #ad7fa8 } /* Literal.String */
.highlight .na { color: #c4a000 } /* Name.Attribute */
.highlight .nb { color: #75507b } /* Name.Builtin */
.highlight .nc { color: #204a87 } /* Name.Class */
.highlight .no { color: #ce5c00 } /* Name.Constant */
.highlight .nd { color: #3465a4; font-weight: bold } /* Name.Decorator */
.highlight .ni { color: #c4a000; text-decoration: underline } /* Name.Entity */
.highlight .ne { color: #cc0000 } /* Name.Exception */
.highlight .nf { color: #a40000 } /* Name.Function */
.highlight .nl { color: #3465a4; font-weight: bold } /* Name.Label */
.highlight .nn { color: #000000 } /* Name.Namespace */
.highlight .nx { color: #000000 } /* Name.Other */
.highlight .py { color: #000000 } /* Name.Property */
.highlight .nt { color: #a40000 } /* Name.Tag */
.highlight .nv { color: #ce5c00 } /* Name.Variable */
.highlight .ow { color: #8f5902 } /* Operator.Word */
.highlight .w { color: #d3d7cf; text-decoration: underline } /* Text.Whitespace */
.highlight .mb { color: #2e3436 } /* Literal.Number.Bin */
.highlight .mf { color: #2e3436 } /* Literal.Number.Float */
.highlight .mh { color: #2e3436 } /* Literal.Number.Hex */
.highlight .mi { color: #2e3436 } /* Literal.Number.Integer */
.highlight .mo { color: #2e3436 } /* Literal.Number.Oct */
.highlight .sa { color: #ad7fa8 } /* Literal.String.Affix */
.highlight .sb { color: #ad7fa8 } /* Literal.String.Backtick */
.highlight .sc { color: #ad7fa8; font-weight: bold } /* Literal.String.Char */
.highlight .dl { color: #ad7fa8 } /* Literal.String.Delimiter */
.highlight .sd { color: #ad7fa8 } /* Literal.String.Doc */
.highlight .s2 { color: #ad7fa8 } /* Literal.String.Double */
.highlight .se { color: #ad7fa8; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #ad7fa8; text-decoration: underline } /* Literal.String.Heredoc */
.highlight .si { color: #ce5c00 } /* Literal.String.Interpol */
.highlight .sx { color: #ad7fa8 } /* Literal.String.Other */
.highlight .sr { color: #ad7fa8 } /* Literal.String.Regex */
.highlight .s1 { color: #ad7fa8 } /* Literal.String.Single */
.highlight .ss { color: #8f5902 } /* Literal.String.Symbol */
.highlight .bp { color: #5c35cc } /* Name.Builtin.Pseudo */
.highlight .fm { color: #a40000 } /* Name.Function.Magic */
.highlight .vc { color: #ce5c00 } /* Name.Variable.Class */
.highlight .vg { color: #ce5c00; text-decoration: underline } /* Name.Variable.Global */
.highlight .vi { color: #ce5c00 } /* Name.Variable.Instance */
.highlight .vm { color: #ce5c00 } /* Name.Variable.Magic */
.highlight .il { color: #2e3436 } /* Literal.Number.Integer.Long */</style></head><body><article class="alectryon-root alectryon-windowed alectryon-coqdoc"><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> List.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Require Import</span> Coq.Logic.FinFun.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">From</span> CasperCBC
  <span class="kn">Require Import</span>
    Lib.Preamble
    Lib.Traces
    CBC.Common <span class="c">(* for weight stuff *)</span>
    VLSM.Common
    VLSM.Decisions
    VLSM.Composition
    VLSM.Equivocation <span class="c">(* for has_been_sent *)</span>
.</span></span></span></pre><div class="doc">
   This module defines liveness, and contains basic defintiions
   that will be used for proving liveness properties,
   constructing protocols designed for liveness, and
   stating the assumptions under which those protocols are live.
 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --></pre><div class="doc">
<a id="lab1"></a><h1 class="section">Liveness</h1>
<div class="paragraph"> </div>

 A composite VLSM is live if every complete trace reaches a <span class="inlinecode"><span class="id" title="var">decision</span></span>
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">Liveness</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span>
    {<span class="nv">CV</span> : consensus_values}
    {<span class="nv">message</span> : <span class="kt">Type</span>}
    {<span class="nv">index</span> : <span class="kt">Type</span>}
    {<span class="nv">Heqd</span> : EqDecision index}
    (<span class="nv">IM</span> : index -&gt; VLSM message)
    (<span class="nv">Hi</span> : index)
    (<span class="nv">constraint</span> : composite_label IM -&gt; composite_state IM * option message -&gt; <span class="kt">Prop</span>)
    (<span class="nv">X</span> := composite_vlsm IM Hi constraint)
    (<span class="nv">ID</span> : <span class="kr">forall</span> <span class="nv">i</span> : index, vdecision (IM i)).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">live</span> : <span class="kt">Prop</span> :=
  <span class="kr">forall</span>
    (<span class="nv">tr</span> : Trace)
    (<span class="nv">Htr</span>: complete_trace_prop X tr),
  <span class="kr">exists</span>
    (<span class="nv">n</span> : nat)
    (<span class="nv">i</span> : index)
    (<span class="nv">st</span> : vstate X),
    trace_nth X tr n = (Some st)
    /\ (ID i) (st i) &lt;&gt; None.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Liveness</span>.</span></span></span></pre><div class="doc">
<a id="lab2"></a><h1 class="section">Clocks</h1>
<div class="paragraph"> </div>

Liveness always requires some notion of time, and assumptions
that messages are not infinitely delayed.

<div class="paragraph"> </div>

We will use logical clocks that assign states and
messages to times in <span class="inlinecode"><span class="id" title="var">nat</span></span>, with messages carrying the
time from the sending component, and messages only
expected to be received by a node at the matching time.
 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">Clocks</span>.</span></span></span></pre><div class="doc">
A clock for a VLSM assigns a time to any state, and is
      nondecreasing on transitions.
   
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Record</span> <span class="nf">ClockFor</span> `(X:VLSM message) : <span class="kt">Type</span> := {
    clock : vstate X -&gt; nat;
    clock_monotone : <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">s</span> <span class="nv">om</span> <span class="nv">s&#39;</span> <span class="nv">om&#39;</span>,
        vtransition X l (s,om) = (s&#39;,om&#39;) -&gt; clock s &lt;= clock s&#39;;
    }.</span></span></span></pre><div class="doc">
For a composite VLSM we usually want to have a separate
      clock for each component
   
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">ClocksFor</span> `(IM:index -&gt; VLSM message) : <span class="kt">Type</span> :=
    <span class="kr">forall</span> <span class="nv">i</span>, ClockFor (IM i).</span></span></span></pre><div class="doc">
A message time function is consistent with a
      set of clocks for a composite VLSM if
      the message time always agrees with the time
      of the sending component at the begining of
      the transition where the message is sent.
   
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Record</span> <span class="nf">MessageTimeProp</span>
        `(IM: index -&gt; VLSM message) `{EqDecision index} Hi constraint
        (X := composite_vlsm IM Hi constraint)
        (clocks : ClocksFor IM)
        (message_time : message -&gt; nat)
    : <span class="kt">Type</span> := {
    message_time_accurate :
      <span class="kr">forall</span> <span class="nv">m</span> <span class="nv">t</span>,
        message_time m = t
        &lt;-&gt; (<span class="kr">forall</span> (<span class="nv">l</span>:vlabel X) <span class="nv">s</span> <span class="nv">om</span> <span class="nv">l</span> <span class="nv">s&#39;</span>,
             vtransition X l (s,om) = (s&#39;, Some m) -&gt; clock _ (clocks _) (s (projT1 l)) = t)
             }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Clocks</span>.</span></span></span></pre><div class="doc">
<a id="lab3"></a><h1 class="section">Plans</h1>
<div class="paragraph"> </div>

Protocols may be designed so that only a subset of validators
are expected to send messages in each phase.

<div class="paragraph"> </div>

Our example protocol will use a fixed that specifies the
expected set of senders for each time.
Here we define the conditions that such a fixed plan will
need to satisfy.

<div class="paragraph"> </div>

Later protocols will dyanmically construct plans to
react to failures, and we will need to generalize
these properties to apply to dynamic plans.
 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">Plan</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span>
    (<span class="nv">index</span>: <span class="kt">Type</span>)
    {<span class="nv">Hweights</span>: Measurable index}
    {<span class="nv">index_listing</span>: list index}
    {<span class="nv">Hfinite</span>: FinFun.Listing index_listing}
  .</span></span></span></pre><div class="doc">
An "odd" set cannot be partitioned into
      two disjoint pieces with equal weight,
      so votes cannot have ties 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">odd_set</span> (<span class="nv">P</span>: index -&gt; <span class="kt">Prop</span>) : <span class="kt">Prop</span> :=
    <span class="kr">forall</span> <span class="nv">l1</span> <span class="nv">l2</span>,
      (<span class="kr">forall</span> <span class="nv">i</span>, P i &lt;-&gt; (In i l1 \/ In i l2)) -&gt;
      NoDup (l1++l2) -&gt;
      sum_weights l1 &lt;&gt; sum_weights l2.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Record</span> <span class="nf">Plan</span> := {
    planned_senders : nat -&gt; index -&gt; <span class="kt">Prop</span>;
    stages_nonempty : <span class="kr">forall</span> <span class="nv">n</span>, ~<span class="kr">forall</span> <span class="nv">v</span>, ~planned_senders n v;
    plan_has_odd_stage: <span class="kr">exists</span> <span class="nv">n</span>, odd_set (planned_senders n);
    recurring_sends: <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">v</span>, <span class="kr">exists</span> <span class="nv">n&#39;</span>, n&#39; &gt; n /\ planned_senders n&#39; v;
    }.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Plan</span>.</span></span></span></pre><div class="doc">
<a id="lab4"></a><h1 class="section">Synchrony Constraint</h1>
<div class="paragraph"> </div>

Synchrony assumptions will be expresed with composition constraints.

<div class="paragraph"> </div>

Currently we define only a strong assumption that doesn't allow
any messages to be delayed, which will be used for example proofs of
liveness.

<div class="paragraph"> </div>

Definitions allowing a limited rate of "syncrhonization faults" will
be added before verifying more robust protocols over more realistic
assumptions.
 
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Section</span> <span class="nf">StrongSynchrony</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Context</span>
    {<span class="nv">message</span> : <span class="kt">Type</span>}
    {<span class="nv">index</span> : <span class="kt">Type</span>}
    (<span class="nv">i0</span> : index)
    {<span class="nv">index_listing</span> : list index}
    (<span class="nv">finite_index</span> : Listing index_listing)
    {<span class="nv">Heqd</span> : EqDecision index}
    (<span class="nv">IM</span> : index -&gt; VLSM message)
    (<span class="nv">Hi</span> : index)
    (<span class="nv">constraint</span> : composite_label IM -&gt; composite_state IM * option message -&gt; <span class="kt">Prop</span>)
    {<span class="nv">Hsents</span> : <span class="kr">forall</span> <span class="nv">i</span>, has_been_sent_capability (IM i)}
    (<span class="nv">has_been_observed_op</span>: <span class="kr">forall</span> <span class="nv">i</span>, state_message_oracle (IM i))
    (<span class="nv">clocks</span> : ClocksFor IM)
    (<span class="nv">message_time</span> : message -&gt; nat)
  .</span></span></span></pre><div class="doc">
This portion of a constraint ensures that messages are received only
      by components at the proper time.

<div class="paragraph"> </div>

      Perhaps this condition should be added to <span class="inlinecode"><span class="id" title="var">MessageTimeProp</span></span> and
      required as a property of the components in <span class="inlinecode"><span class="id" title="var">IM</span></span> rather than
      imposed as a composition constraint.
   
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">delivery_time_constraint</span> :
    composite_label IM -&gt; composite_state IM * option message -&gt; <span class="kt">Prop</span>
    := <span class="kr">fun</span> <span class="nv">l</span> <span class="nv">som</span> =&gt;
         <span class="kr">let</span> (<span class="nv">i</span>,_) := l <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">s</span>,om) := som <span class="kr">in</span>
         <span class="kr">match</span> om <span class="kr">with</span>
         | Some m =&gt; message_time m = clock _ (clocks i) (s i)
         | None =&gt; <span class="kt">True</span>
         <span class="kr">end</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">all_earlier_messages_received</span> (<span class="nv">i</span>:index) (<span class="nv">s</span>:composite_state IM) : <span class="kt">Prop</span> :=
    <span class="kr">forall</span> <span class="nv">msg</span>, (<span class="kr">exists</span> (<span class="nv">j</span>:index), has_been_sent (IM j) (s j) msg) -&gt;
                message_time msg &lt;= clock _ (clocks i) (s i) -&gt;
                has_been_observed_op i (s i) msg.</span></span></span></pre><div class="doc">
This portion of a constraint prevents a component from advancing its clock
      if it has not received all oustanding messages from the time
      it is leaving.

<div class="paragraph"> </div>

      N.B. As written, this does not prevent the possiblity that some
      other component which is still in the earlier time hasn't even
      sent a message yet. Combined with the use of <span class="inlinecode"><span class="id" title="var">lt</span></span> in
      <span class="inlinecode"><span class="id" title="var">all_earlier_messages_received</span></span>, and the <span class="inlinecode"><span class="id" title="var">delivery_time_constraint</span></span>,
      this component would never be able to advance its clock again
      after such a "late send".
   
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">timely_reception_constraint</span>:
    composite_label IM -&gt; composite_state IM * option message -&gt; <span class="kt">Prop</span>
    := <span class="kr">fun</span> <span class="nv">l</span> <span class="nv">som</span> =&gt;
         <span class="kr">let</span> (<span class="nv">i</span>,l_i) := l <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">s</span>,om) := som <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">s&#39;</span>,_) := vtransition (IM i) l_i (s i,om) <span class="kr">in</span>
         clock _ (clocks i) (s i) &lt; clock _ (clocks i) s&#39;
         -&gt; all_earlier_messages_received i s.</span></span></span></pre><div class="doc">
This strong constraint allows no equivocations and
      no failures of synchrony.
   
</div><pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="highlight">  </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Definition</span> <span class="nf">no_synch_faults_no_equivocation_constraint</span> :
    composite_label IM -&gt; composite_state IM * option message -&gt; <span class="kt">Prop</span>
    := <span class="kr">fun</span> <span class="nv">l</span> <span class="nv">som</span> =&gt;
         no_equivocations IM i0 (free_constraint _) finite_index Hsents l som
         /\ delivery_time_constraint l som
         /\ timely_reception_constraint l som.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">StrongSynchrony</span>.</span></span></span></pre></article></body></html>